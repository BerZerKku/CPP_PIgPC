/*
 * iec_60870_5_101.h
 *
 *  Created on: 21.04.2015
 *      Author: Shcheblykin
 */

#ifndef CIEC101_H_
#define CIEC101_H_

#include <stdint.h>

/**	\defgroup Notation Стиль оформления.
 *
 *	Префикс:
 *	- b - булева переменная, bError;
 *	- cl - класс, clIec101;
 *	- e - перечисление, eTypeId;
 *	- i8 - целочисленная переменная размером 8 бит, i8Error;
 *	- i16 - целочисленная переменная размером 16 бит, i16Error;
 *	- p - указатель, pArray;
 *	- r - ссылка, rArray;
 *	- s - строка в RAM, sDate;
 *	- sf - строка в FLASH, sfDate;
 *	- st - структура, SData;
 *	- u - объединение union, uAsdu;
 *	- u8 - беззнаковая переменная размером 8 бит, u8Size;
 *	- u16 - беззнаковая переменная размером 8 бит, u16Size;
 *	- v - отсутствие типа void, vReserved.
 *
 *	Префикс:
 *	- c_ - статическая переменная функции, c_u8Address.
 *	- g_ - глобальная переменная, g_u8Address;
 *	- m_ - переменная-член, m_u8Address;
 *	- s_ - статическая переменная-член, s_u8AddressMax;
 *
 *	Префикс:
 *	- C - класс, CIec101;
 *	- E - перечисление, ECot;
 *	- S - структура, SDate;
 *	- T - новый тип данных (typedef);
 *	- U - объединение, UAsdu.
 *
 *	Имена локальным переменным даются без данных префиксов.
 */

/** \defgroup Main МЭК 60870-5-101
 *
 */

/**	\defgroup Definitions Термины и определения
 *	\ingroup Main
 *
 *	- Асинхронный (старт-стопный) формат передачи - формат с обрамлением каждого
 *	символа длиной от 5 до 8 бит стартовым битом "0", опциональным битом четности
 *	(нечетности) и стоповым битом (двумя битами) "1". Интервалы между символами
 *	могут иметь произвольную длительность при состоянии линии "1".
 *
 *	- <b> Controlling Station </b> - первичная станция, которая может инициировать
 *	процедуру обмена информацией.
 *	- <b> Controlled Station </b> - вторичная станция, которая может передавать сообщения
 *	(данные или квитанции) только после запроса первичной станции.
 *
 *	- <b> Unbalanced transmission system </b> - небалансная передача, режим передачи,
 *	при котором только одна станция - первичная - может начинать передачу информации,
 *	а другая станция (все остальные при многоточечном канале) - вторичная -
 *	передает только после запроса первичной станции.
 *
 *	- \b ASDU - блок данных прикладного уровня (Application service data unit).
 *	- \b COI - причина инициализации (Cause of initialisation).
 *	- \b COT - причина передачи (Cause Of Transmission).
 *	- \b FC - функциональный код (Function code).
 *	- \b FCB - бит счета кадров (Frame count bit).
 *	- \b QOI - описатель запроса (Qualifier of interrogation).
 */

/**	\defgroup Frame Формат протокола FT1.2
 *	\ingroup Main
 *
 * 	В соответствии с ГОСТ Р МЭК 870-5-101 данный отраслевой протокол использует
 *	на канальном уровне только асинхронный протокол FT1.2. Формат слова 8Б1, т.е.
 *	8 информационных бит с контрольным битом проверки на четность (even) и одним
 *	стоп-битом.
 *
 *	Предусмотрено использование следующих видов информационных кадров:
 *	- кадр фиксированной длины;
 *	- кадр переменной длины;
 *	- однобайтовые посылки <b> CONTROL1 = E5h </b> и <b> CONTROL2 = A2h </b>
 *	(в данном случае не реализованы).
 *
 *	Кадры  пользовательских данных с <b> ФИКСИРОВАНОЙ ДЛИНОЙ </b> состоят из стартового
 *	слова, фисксированного числа L байтов пользовательских данных, контрольной
 *	суммы (КС) и слова окончания.
 *
 *	Правила передачи:
 *	- R1 - спокойное состояние линии - двоичная 1;
 *	- R2 - каждая комбинация содержит стартовый бит (двоичный 0), 8 информационных
 *	битов, один бит четности, один стоп-бит (двоичная 1);
 *	- R3 - между символами кадра не разрешается иметь интервалы спокойного состояния;
 *	- R4 - при определении ошибки в соответствии с правилом R6 требуется минимальный
 *	интервал между кадрами, равный 33 бит спокойного состояния линии;
 *	- R5 - последовательность слов пользовательских данных оканчивается контрольной
 *	суммой из 8 бит. Контрольная сумма - это арифметическая сумма, пренебрегающая
 *	переполнением (сумма по модулю 256) у всех байтов пользовательских данных;
 *	- R6 - приемник контролирует:
 *		- по слову:
 *			- старт-бит;
 *			- стоп-бит;
 *			- бит четности;
 *		- по кадру:
 *			- стартовое слово \b 0x10;
 *			- контрольную сумму кадра;
 *			- слово окончания \b 0x16;
 *		- При обнаружении ошибки контролируется интервал спокойного состояния
 *	линии, определяемый в соответствии с правилом R4.
 *
 *	Кадр бракуется, если хотя бы одна из проверок дает отрицательный результат.
 *	При положительных результатах проверок кадр выдается пользователю.
 *
 *	Кадры пользовательсих данных с <b> ПЕРЕМЕННОЙ ДЛИНОЙ </b> состояи из двух
 *	стартовых одинаковых слов (1-го и 4-ого слов), двух одинаковых слов, определяющих
 *	число L байтов пользовательских данных (2-го и 3-го слов), пользовательских
 *	данных, слова контрольной суммы кадра и одного слова окончания.
 *
 *	L - число от 0 до 255. выраженное в двоичном исчислении.
 *	Правила передачи:
 *	- R1, R2, R3, R4, R5 - см ждя кадра с фиксированной длиной;
 *	- R6 - приемник контролирует:
 *		- по слову:
 *			- стартовый бит;
 *			- стоп-бит;
 *			- бит четности;
 *		- по кадру:
 *			- стартовые слова в начале и конце загаловка кадра \b 0x68;
 *			- идентичность двух слов, характеризующих длину \b L;
 *			- число принимаемых слов равное <b> L + 6 </b>;
 *			- контрольную сумму кадра;
 *			- слово окончания \b 0x16;
 *		- При обнаружении ошибки контрлирует интервал спокойного состояния линии,
 *		определенный в соответствии с правилом R7.
 *
 *	Кадр бракуется, если хотя бы один из контролируемых элементов неправильный.
 *	При положительных результатах проверок кадр выдается пользователю.
 *
 *	\note МЭК 870-5-1-95 6.2.4.2.1 Формат FT1.2: кадоры с фиксированным числом
 *	байтов пользовательских данных.
 *	\note IEC 870-5-101 4 Standard frame format.
 */

/**	\brief Класс работы с протоколом МЭК 60870-5-101.
 *
 *	Для работы протокола необходимо:
 *	- переопределить виртуальные обработчики под свои данные;
 *	- вызывать функцию \a push() при принятии очередного байта данных, например
 *	в прерывании приема;
 *	- по покончанию передачи ответа вызвать функцию \a setReadState();
 *	- вызывать функцию \a tick() с заданным в функции \a setTick() периодом,
 *	например из прерывания таймера;
 *
 *	Для начала работы необходимо выполнить следующие шаги:
 *	- установить адрес устойства в сети 60870-5-101, например \a setAddress(42);
 *	- установить шаг счета паузы между принятыми данными, например для скорости
 *	19200 бит/с и периодом вызова функции \a tick() 50мкс \a setTick(19200, 50);
 *	- запустить протокол \a setEnable().
 *
 *	Для того чтобы не тратить времени на разбор посылки на "лету", ее окончание
 *	определяется по наличию интервала спокойного состояния более 1.5 символов.
 *
 *	При обнаружении ошибки приема по УАПП (например не совпал бит контроля четности),
 *	необходимо установить состояние \a #STATE_READ_ERROR.
 *
 *	Изначально, согласно протоколу, должны прийти сигналы сброса с первичной
 *	станции и только после этого протокол начинает работать в полном объеме.
 *
 *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
 *	unbalanced transmission systems.
 *
 *	Если в посылке будут обнаружены ошибки, то требуется в случае кадра
 *	фиксированной длины требуется интервал спокойного состояния не менее 33 бит,
 *	а для переменной - не менее 22 бит. Для упрощения всегда ждем 33 бита.
 *
 *	При обнаружении принятой посылки \a isReadData(), надо вызвать функцию
 *	\a readData().
 *
 *	Вызвать функцию передачи ответа \a sendData() и если она вернет не нулевое
 *	количество подготовленных для передачи байт, отправить их.
 *
 *	Общий адрес станции \a #s_u8CommonAddressOfAsdu.
 *
 *	Размер буфера для приема/передачи не должен превышать 255 байт.
 *
 * 	@see STATE
 */
class CIec101
{
#ifdef TEST_FRIENDS
    TEST_FRIENDS;
#endif

    /// Максимальное значение паузы между принятыми байтами в тиках
    static const uint16_t s_u16TickMax = 60000;  // при тике 50мкс, будет 3с

    /// Общий адрес ASDU.
    static const uint8_t s_u8CommonAddressOfAsdu = 1;

    /// Классификатор переменной структуры
    static const uint8_t s_u8VariableStructureQualifier = 1;

    /// Ошибочный адрес, устанавливается по-умолчанию.
    static const uint8_t s_u8AddressErr = 0;
    /// Минимальный адрес устройства в сети.
    static const uint8_t s_u8AddressMin = 1;
    /// Максимальный адрес устройства в сети (как и в MODBUS).
    static const uint8_t s_u8AddressMax = 247;
    /// Глобальный адрес.
    static const uint8_t s_u8AddressGlb = 255;

    /// Слово окончания.
    static const uint8_t s_u8FrameStopCharacter = 0x16;

    /// Размер кадра с постоянной длиной.
    static const uint8_t s_u8SizeOfFrameFixLenght = 5;

    /// Минимальный размер кадра с переменной длиной.
    static const uint8_t s_u8SizeOfFrameVarLenghtMin = 15;

protected:
    /**	\struct SCp56Time2a
     * 	\brief Метка времени "Время 2а в двоичном коде" CP56time2a.
     *
     * 	\note
     * 	В значении миллисекунд храняться также и секунды.
     *
     * 	\var SCp56Time2a::milliseconds
     * 		UI16[1..16] <0..59999>
     *
     *	\var SCp56Time2a::minutes
     *		 UI6[17..22] <0..59>
     *
     *	\var SCp56Time2a::res1
     *		BS1[23]
     *		\details Бит может использоваться в направлении контроля для указания,
     * 		добавлена ли метка времени к объекту информации, когда он получен от RTU
     * 		время), или метка времени установлена промежуточным оборудованием,
     * 		таким как станция-концентратор, или самой контролирующей станцией
     * 		(измененное время):
     * 		- <0> - истинное время,
     * 		- <1> - измененное время.
     *
     *	\var SCp56Time2a::iv
     *		BS1[24] <0..1>
     * 		- <0> - действительно,
     * 		- <1> - недействительно.
     *
     * 	\var SCp56Time2a::hours
     * 		UI5[25..29] <0..23>
     *
     * 	\var SCp56Time2a::res2
     *		BS2[30..31]
     *
     *	\var SCp56Time2a::su
     *		BS1[32] <0..1>
     *		\details Бит летнего времени \a SU опционально используется как
     * 		дополнительная информация для укзания, какое время (стандартное или
     * 		летнее) действует в настоящий момент. Это может быть полезно для
     * 		присвоения правильного времени объектам информации, генерируемым в
     * 		течение первого часа после переключения со стандартного на летнее время:
     * 		- <0> - стандартное время,
     * 		- <1> - летнее время.
     *
     *	\var SCp56Time2a::dayOfMonth
     *		UI5[33..37] <1..31>
     *
     *	\var SCp56Time2a::dayOfWeek
     *		UI3[38..40] <1..7>
     * 		- <0> - день недели не используется.
     *
     *	\var SCp56Time2a::months
     *		UI4[41..44] <1..12>
     *
     *	\var SCp56Time2a::res3
     *		BS4[45..48]
     *
     *	\var SCp56Time2a::years
     * 		UI7[49..55] <0..99>
     *
     * 	\var SCp56Time2a::res4
     * 		BS1[56]
     */
    typedef struct __attribute__((__packed__))
    {
        uint16_t milliseconds : 16;  ///< Миллисекунды.
        uint8_t  minutes      : 6;   ///< Минуты.
        uint8_t  res1         : 1;   ///< Резерв 1 - RES1.
        uint8_t  iv           : 1;   ///< Недействительно - IV.
        uint8_t  hours        : 5;   ///< Часы.
        uint8_t  res2         : 2;   ///< Резерв 2 - RES2.
        uint8_t  su           : 1;   ///< Летнее время - SU .
        uint8_t  dayOfMonth   : 5;   ///< День месяца.
        uint8_t  dayOfWeek    : 3;   ///< День недели.
        uint8_t  months       : 4;   ///< Месяцы.
        uint8_t  res3         : 4;   ///< Резерв 3 - RES3.
        uint8_t  years        : 7;   ///< Годы.
        uint8_t  res4         : 1;   ///< Резерв 4 - RES4.
    } SCp56Time2a;

    /**	\brief Причина передачи (Сause of Transmission).
     *
     * 	\note МЭК 870-5-101-2006 7.2.3 Причина передачи.
     *	\note IEC 870-5-101 4.2.8 Cause of transmission
     */
    typedef enum __attribute__((__packed__))
    {
        COT_NOT_USED = 0,  ///< \b <0> Не используется (not used).
        COT_PER_CYC  = 1,  ///< \b <1> Периодически, циклически (per/cyc).
        COT_BACK     = 2,  ///< \b <2> Фоновое сканирование (background scan).
        COT_SPONT    = 3,  ///< \b <3> Спорадически (spontaneous).
        COT_INIT = 4,  ///< \b <4> Сообщение об инициализации (initialised).
        COT_REQ  = 5,  ///< \b <5> Запрос или запрашиваемые данные (request or requested).
        COT_ACT  = 6,  ///< \b <6> Активация (activation).
        COT_ACTCON = 7,  ///< \b <7> Подтверждение активации (activation confirmation).
        COT_DEACT = 8,  ///< \b <8> Деактивация (deactivation).
        COT_DEACTON = 9,  ///< \b <9> Подтверждение деактивации (deactivation confirmation).
        COT_ACTTERM = 10,  ///< \b <10> Завершенеи активации (activation termination).
        COT_RETREM = 11,  ///< \b <11> Обратная информация, вызванная удаленной командой (return
                          ///< information caused by a remote command).
        COT_RETLOC = 12,  ///< \b <12> Обратная информация, вызванная местной командой (return
                          ///< information caused by a local command).
        COT_FILE = 13,    ///< \b <13> Передача файлов (file transfer).
        COT_INROGEN =
            20  ///< \b <20> Ответ на опрос станции (interrogated by general interrogation).
    } ECot;

private:
    ///	Флаги текущих функций.
    typedef enum __attribute__((__packed__))
    {
        FUNCTION_NO         = 0x00,  ///< \b <0x00> Нет текущих функций.
        FUNCTION_RESET_WAIT = 0x01,  ///< \b <0x01> Ожидание команды сброса.
        FUNCTION_RESET_END = 0x02,  ///< \b <0x02> Сообщение об окончани сброса.
        FUNCTION_RESET         = 0x03,  ///< \b <0x03> Ожидание сброса (общее).
        FUNCTION_INTERROG_CONF = 0x04,  ///< \b <0x04> Подтверждение опроса.
        FUNCTION_INTERROG_MONIT = 0x08,  ///< \b <0x08> Данные опроса, либо его окончание.
        //		FUNCTION_INTERROG		= 0x0C,	///< \b <0x0C> Наличие опроса
        //(общее).
        FUNCTION_TIME_SYNCH_CONF = 0x10,  ///< \b <0x10> Подтверждение синхронизации времени.
        //		FUNCTION_TIME_SYNCH_END	= 0x20,	///< \b <0x20> Окончание синхронизации
        //времени.
        FUNCTION_EVENT_CLASS_1 = 0x40,  ///< \b <0x40> Наличие данных класса 1 на передачу.
        //		FUNCTION_EVENT_CLASS_2	= 0x80,	///< \b <0x80> Наличие данных класса 2 на
        //передачу.
        FUNCTION_IS_ACD = 0x48  ///< \b <0x48> Проверка флагов с наличием данных на передачу.
    } EFunction;

    /// Формат кадра (стартовое слово).
    typedef enum __attribute__((__packed__))
    {
        FRAME_START_ERROR         = 0x00,  ///< \b <0x00> Ошибочное стартовое слово кадра (нет в МЭК).
        FRAME_START_CHARACTER_FIX = 0x10,  ///< \b <0x10> Cтартовое слово кадра с постоянной длиной.
        FRAME_START_CHARACTER_VAR = 0x68  ///< \b <0x68> Cтартовое слово кадра с переменной длиной.
    } EFrameStartCharacter;

    /** \brief Идентификатор типа.
     *
     *	\note МЭК 870-5-5-96 6 Основные прикладные функции.
     *	\note IEC 870-5-101 4.2.6 Type identification.
     *
     *
     * 	Байт 1 ИДЕНТИФИКАТОРА БЛОКА ДАННЫХ - ИДЕНТИФИКАТОР ТИПА определяет
     * 	структуру, тип и формат ОБЪЕКТА(ов) ИНФОРМАЦИИ данного блока ASDU.
     *
     *	При определеении ИДЕНТИФИКАТОРА ТИПА используют следующие условные
     *	обозначения (метки):
     *	- 1-ый элемент метки:
     *		- M - передача в направлении контроля;
     *		- С - передача в направлении управления;
     *		- P - передача параметров;
     *		- F - передача файлов.
     *	- 2-ой элемент метки:
     *		- две буквы, вид информации.
     *	- 3-ий элемент метки:
     *		- T - наличие метки времени;
     *		- N - отсутствие метки времени.
     *	- 4-ый элемент метки:
     *		- обозначение формата данных (A, B, C и т.д.).
     *
     * 	ИДЕНТИФИКАТОР ТИПА = UI8[1..8]<1..255>:
     * 	- <0> - не используется;
     * 	- <1..127> - диапазон определенный в стандарте;
     * 	- <128..255> - диапазон не определяется.
     * 	Значения индентификатора типа от 136 до 255 могут быть определены независимо
     * 	друг от друга пользователями настоящего стандарта. Однако полная совместимость
     * 	может быть достигнута только при использовании ASDU со значениями
     * 	ИДЕНТИФИКАТОР ТИПА от 1 до 127.
     *
     * 	ОБЪЕКТЫ ИНФОРМАЦИИ с МЕТКОЙ ВРЕМЕНИ или без нее отличаются различными
     * 	значениями ИДЕНТИФИКАТОРА ТИПА.
     */
    typedef enum __attribute__((__packed__))
    {
        TYPE_ID_M_SP_NA_1 = 1,  ///< \b <1> Одноэлементная информация без метки времени.
        TYPE_ID_M_SP_TB_1 =
            30,  ///< \b <30> Одноэлементная информация с меткой времени СР56Время2а.
        TYPE_ID_M_EI_NA_1 = 70,   ///< \b <70> Окончение инициализации.
        TYPE_ID_C_IC_NA_1 = 100,  ///< \b <100> Команда опроса.
        TYPE_ID_C_CS_NA_1 = 103  ///< \b <103> Команда синхронизации часов.
    } ETypeId;


    /**	\enum EFcPrimary
     * 	\brief Функциональные коды поля управления от первичной станции.
     *
     *	Дополнительно разрешены ответы <14> "Услуги канала не работают"
     *	или <15> "Услуги канала не предусмотрены".
     *
     *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
     *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
     *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
     *
     *	\var RESET_REMOTE_LINK
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <0> - положительное подтверждение;
     *		- <1> - отрицательное подтверждение.
     *
     *	\var RESET_OF_USER_PROCESS
     *		TODO На данный момент не поддерживается.
     *		 Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <0> - положительное подтверждение;
     *		- <1> - отрицательное подтверждение.
     *
     *	\var USER_DATA_CONFIRM
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <0> - положительное подтверждение;
     *		- <1> - отрицательное подтверждение.
     *
     *	\var USER_DATA_NO_REPLY
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- Нет ответа.
     *
     *	\var REQUEST_FOR_ACCESS_DEMAND
     *		TODO На данный момент не поддерживается.
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <11> - ОТВЕТ: состояние канала.
     *
     *	\var REQUEST_STATUS_OF_LINK
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <11> - ОТВЕТ: состояние канала.
     *
     *	\var REQUEST_USER_DATA_CLASS_1
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <8> - ОТВЕТ: данные пользователя;
     *		- <9> - ОТВЕТ: запрашиваемые данные недоступны.
     *
     *	\var REQUEST_USER_DATA_CLASS_2
     *		Разрешенные функциональные коды и услуги во вторичном направлении:
     *		- <8> - ОТВЕТ: данные пользователя;
     *		- <9> - ОТВЕТ: запрашиваемые данные недоступны.
     */
    typedef enum __attribute__((__packed__))
    {
        RESET_REMOTE_LINK = 0,  ///< \b <0> Сброс удаленного канала (FCV = 0).
        //		RESET_OF_USER_PROCESS 		= 1,	///< \b <1> Сброс процесса
        //пользователя (FCV = 0).
        USER_DATA_CONFIRM = 3,  ///< \b <3> Пользовательские данные с ответом (FCV = 1).
        USER_DATA_NO_REPLY = 4,  ///< \b <4> Пользовательские данные без ответа (FCV = 0).
        //		REQUEST_FOR_ACCESS_DEMAND 	= 8, 	///< \b <8> Запрос доступа по
        //требованию (FCV = 0).
        REQUEST_STATUS_OF_LINK = 9,  ///< \b <9> Запрос о соcтоянии канала (FCV = 0).
        REQUEST_USER_DATA_CLASS_1 = 10,  ///< \b <10> Запрос данных класса 1 (FCV = 1).
        REQUEST_USER_DATA_CLASS_2 = 11  ///< \b <11> Запрос данных класса 2 (FCV = 1).
    } EFcPrimary;

    /**	\enum EFcSecondary
     * 	\brief Функциональные коды поля управления от вторичной станции.
     *
     *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
     *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
     *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
     */
    typedef enum __attribute__((__packed__))
    {
        CONFIRM_ACK = 0,  ///< \b <0> Положительное подтверждение.
        CONFIRM_NACK =
            1,  ///< \b <1> Отрицательное подтверждение (сообщение не принято, линия занята).
        RESPOND_USER_DATA = 8,  ///< \b <8> ОТВЕТ: пользовательские данные.
        RESPOND_NACK      = 9,  ///< \b <9> ОТВЕТ: запрошенные данные отсутствуют (недоступны).
        RESPOND_STATUS_OF_LINK = 11,  ///< \b <11> ОТВЕТ: состояние канала связи или запрос доступа.
        //		LINK_SERV_NOT_FUNC		= 14,	///< \b <14> Канальный сервис не
        //работает ("Услуги канала не работают").
        LINK_SERV_NOT_IMPL = 15  ///< \b <15> Канальный сервис не встроен.
    } EFcSecondary;

    /**	\brief Причина инициализации (Cause of initialisation).
     *
     *	\note МЭК 870-5-101-2006 7.2.6.21 Причины инициализации.
     *	\note IEC 870-5-101 5.2.3.1 End of initialisation.
     */
    typedef enum __attribute__((__packed__))
    {
        COI_LOCAL_POWER_ON = 0,  ///< \b <0> Местное включение питания.
        COI_LOCAL_MANUAL_RESET = 1,  ///< \b <1> Местный ручной возврат в исходное состояние.
        COI_REMOTE_RESET = 2  ///< \b <2> Удаленный возврат в исходное состояние.
    } ECoi;

    /**	\brief Указатель опроса (Qualifier of interrogation).
     *
     *	\note МЭК 870-5-101-2006 7.2.6.22 Указатель опроса.
     *	\note IEC 870-5-101 5.2.4.1 Interrogation command.
     */
    typedef enum __attribute__((__packed__))
    {
        QOI_NOT_USED                 = 0,  ///< \b <0> Не используется.
        QOI_STATION_ITERROGATION_GLB = 20  ///< \b <20> Опрос станции (общий).
    } EQoi;

    /**	\struct SCauseOfTransmission
     * 	\brief Причина передачи
     *
     *	\var SCauseOfTransmission::t
     *		BS1[8] <0..1>
     *		\details В дополнение к ПРИЧИНЕ ПЕРЕДАЧИ бит признака теста определяет
     *		ASDU, которые были созданы во время тестирования. Этот бит используется,
     *		например, для проверки тракта передачи аппаратуры без управления
     *		процессом:
     *		- <0> - не тест;
     *		- <1> - тест.
     *
     *	\var SCauseOfTransmission::pN
     *		BS1[7] <0..1>
     *		\details Показывает , какое (положительное или отрицательное) подтверждение
     *		активации требуется для передачи прикладной функции. В случае, когда,
     *		бит P/N не используется, он равен 0.
     *		- <0> - положительное подтверждение;
     *		- <1> - отрицательное подтверждение.
     *
     *	\var SCauseOfTransmission::cot
     *		UI6[1..6]<0..63>
     *		\details #ECot.
     */
    typedef struct __attribute__((__packed__))
    {
        ECot    cot : 6;  ///< Причина.
        uint8_t pN  : 1;  ///< P/N.
        uint8_t t   : 1;  ///< Тест.
    } SCauseOfTransmission;

    /** \struct SControlFieldPrimary
     * 	\brief Поле управления при передаче от первичной станции к вторичной.
     *
     * 	\var SControlFieldPrimary::res
     *
     * 	\var SControlFieldPrimary::prm
     * 		- <1> - сообщение передается от первичной станции.
     *
     * 	\var SControlFieldPrimary::fcb
     * 		- <0>, <1> - чередующиеся значения бита при последовательных передачах
     * 		ПОСЫЛКА/ПОДТВЕРЖДЕНИЕ или ЗАПРОС/ОТВЕТ для данной станции. При команде
     * 		сброса бит всегда равен нулю, а после приема этой команды вторичная
     * 		станция всегда ожидает следующий кадр от первичной станции к вторичной
     *		станции с \a #fcv, равным 1, чтобы установить противоположное значение
     *		\a #fcb, т.е. 1.
     *
     * 	\var SControlFieldPrimary::fcv
     * 		- 0 - изменение бита #fcb неверно и не должно контролироваться при приеме,
     * 		но значение #fcb должно запоминаться для контроля при следующем приеме с #fcv = 1;
     * 		- 1 - изменение бита #fcb правильно и должно контролироваться при приеме.
     *
     * 	\var SControlFieldPrimary::function
     * 		\a #EFcPrimary
     */
    typedef struct __attribute__((__packed__))
    {
        EFcPrimary function : 4;  ///< Функциональный код (function code).
        uint8_t fcv : 1;  ///< Законность бита счета кадров (frame count bit valid.).
        uint8_t fcb : 1;  ///< Бит счета кадров (frame count bit).
        uint8_t prm : 1;  ///< Первичное сообщение (primary message bit).
        uint8_t res : 1;  ///< Резерв.
    } SControlFieldPrimary;

    /**	\struct SControlFieldSecondary
     * 	\brief Поле управления при передаче от вторичной станции к первичной.
     *
     *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
     *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
     *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
     *
     * 	\var SControlFieldSecondary::res
     *
     * 	\var SControlFieldSecondary::prm
     * 		- <0> - сообщение передается от вторичной станции.
     *
     * 	\var SControlFieldSecondary::acd
     * 		- <0> - нет запроса на передачу данных класса 1;
     * 		- <1> - запрос на передачу данных класса 1.
     *
     *	\var SControlFieldSecondary::dfc
     * 		- <0> - прием сообщений возможен;
     * 		- <1> - прием сообщений не возможет из-за переполнения буфера.
     *
     *	\var SControlFieldSecondary::function
     * 		\a #EFcSecondary
     */
    typedef struct __attribute__((__packed__))
    {
        EFcSecondary function : 4;  ///< Функция.
        uint8_t      dfc : 1;  ///< Контроль потока данных (data flow control).
        uint8_t acd : 1;  ///< Бит требования запроса данных (access demand).
        uint8_t prm : 1;  ///< Первичное сообщение (primary message bit).
        uint8_t res : 1;  ///< Резерв.
    } SControlFieldSecondary;

    /// Поле управления.
    typedef union
    {
        uint8_t              common;  ///< Общее.
        SControlFieldPrimary primary;  ///< От первичной ко вторичной станции.
        SControlFieldSecondary secondary;  ///< От вторичной к первичной станции.
    } UControlField;

    /** \struct SDataUnitId
     * 	\brief Идентификатор блока данных.
     *
     * 	\var SDataUnitId::typeId
     * 		UI8[1..8]<1..255>
     *		\details Определяет структуру, тип и	формат объекта(ов) информации
     * 		данного блока ASDU. Значение .	Контролирующая станция игнорирует ASDU
     * 		с не определенным для данной системы значением идентификатора типа.
     *
     * 	\var SDataUnitId::variableStructureQualifier
     * 		- Число = UI7[1..7]<0..127>:
     * 			- <0> - ASDU не содержит ОБЪЕКТОВ ИНФОРМАЦИИ;
     * 			- <1>..<127> - число ОБЪЕКТОВ или ЭЛЕМЕНТОВ ИНФОРМАЦИИ.
     * 		- SQ = BS1[8]<0..1>:
     * 			- <0> - адресация индивидуальных ОДИНОЧНЫХ ЭЛЕМЕНТОВ или КОМБИНАЦИЙ
     * 			ЭЛЕМЕНТОВ в наборе ОБЪЕКТОВ ИНФОРМАЦИИ одинакового типа;
     * 			- <1> - адресация ПОСЛЕДОВАТЕЛЬНОСТИ ОДИНОЧНЫХ ЭЛЕМЕНТОВ ИНФОРМАЦИИ
     * 			или одинаковых КОМБИНАЦИЙ ЭЛЕМЕНТОВ в единственном объекте ASDU.
     *
     * 	\var SDataUnitId::causeOfTramsmission
     * 		\a #ECot
     *
     * 	\var SDataUnitId::commonAddressOfASDU
     * 		Это адрес станции, который может быть структурирован, чтобы иметь
     * 		возможность адресации ко всей станции или только к отдельному
     * 		сектору станции.
     */
    typedef struct
    {
        ETypeId              typeId;  ///< Идентификатор типа.
        uint8_t              variableStructureQualifier;  ///< Классификатор переменной структуры.
        SCauseOfTransmission causeOfTramsmission;  ///< Причина передачи.
        uint8_t              commonAddressOfASDU;  ///< Общий адрес ASDU.
    } SDataUnitId;

    /// Общие поля структуры ASDU для всех команд
    typedef struct
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
    } SAsduCommon;

    /**	\struct SSiq
     * 	\brief Одноэлементная информация с описателем качества.
     *  Single-point information with quality descriptor.
     *
     * 	\var SSiq::spi
     * 		BS[1]<0..1>
     * 		\details <b> Значение бита ТС </b>:
     * 		- <0> - выкл;
     * 		- <1> - вкл.
     *
     * 	\var SSiq::res
     * 		BS3[2..4]<0>
     *
     * 	\var SSiq::bl
     * 		BS1[5]<0..1>
     *		\details Значение ОБЪЕКТА ИНФОРМАЦИИ блокировано для передачи, оно
     * 		остается в состоянии, в котором было до блокировки. Блокировка и
     * 		деблокировака могут инициироваться местным блокирующим устройством
     * 		или автоматически на основаниии местной причины:
     * 		- <0> - нет блокировки;
     * 		- <1> - блокировка.
     *
     * 	\var SSiq::sb
     * 		BS[6]<0..1>
     * 		\details Значение ОБЪЕКТА ИНФОРМАЦИИ поступает на вход или от
     * 		оператора (диспетчера) или от автоматического истончника:
     * 		- <0> - нет замещения;
     * 		- <1> - замещение.
     *
     * 	\var SSiq::nt
     * 		BS[7]<0..1>
     * 		\details Значение акутально, если большинство опросов было успешным.
     * 		Значение неактуально, если оно не обновлялось в течение заданного
     * 		промежутка времени или было недоступно:
     * 		- <0> - актуальное значение;
     * 		- <1> - неактуальное значение.
     *
     * 	\var SSiq::iv
     * 		BS[8]<0..1>
     * 		\details Действительно, если правильно получено. После того, как
     * 		функция опроса обноруживает неправильные условия в источнике информации
     * 		(поврежденные или неработающие устройства опроса), значение величины
     * 		маркируется как недействительное. При этих условаиях значение ОБЪЕКТА
     * 		ИНФОРМАЦИИ не определено. Бит "недействительно" используется для
     * 		указания получателю, что значение величичны может быть неправлильным
     *		и им нельзя пользоваться:
     *		- <0> - действительная;
     *		- <1> - недействительная.
     */
    typedef struct __attribute__((__packed__))
    {
        uint8_t spi : 1;  ///< Одноэлементная информация (single point information).
        uint8_t res : 3;  ///< Резерв.
        uint8_t bl  : 1;  ///< Блокировка/нет блокировки.
        uint8_t sb  : 1;  ///< Проведено замещение/ нет замещения.
        uint8_t nt  : 1;  ///< Неактуальное/актуальное значение.
        uint8_t iv : 1;  ///< Недействительное/действительное значение.
    } SSiq;

    /**	\struct SCoi
     * 	\brief Причины инициализации (Cause Of Initialisation).
     *
     *	\var SCoi::cause
     *		UI7[1..7]<0..127>
     *		\details \a #ECoi
     *
     *	\var SCoi::init
     *		BS1[8]<0..1>
     *		- <0> - инициализация при неизменных местных параметрах;
     *		- <1> - инициализация после изменения местных параметров.
     */
    typedef struct __attribute__((__packed__))
    {
        ECoi    cause : 7;  ///< Причина.
        uint8_t init  : 1;  ///< Инициализация.
    } SCoi;

    /**	\struct SQoi
     * 	\brief Указатель опроса (Qualifier of interrogation).
     *
     *	\var SQoi::qoi
     *		UI8[1..8]<0..255>
     *		\details \a #EQoi
     *
     */
    typedef struct __attribute__((__packed__))
    {
        EQoi qoi;  ///< Указатель опроса.
    } SQoi;

    /**	\brief Одноэлементная информация без метки времени (Single-point information without time
     *tag).
     *
     * 	Идентификатор типа = 1.
     *
     *	\note МЭК 870-5-101 7.3.1.1 Идентификатор типа 1: M_SP_NA_1.
     *	\note IEC 870-5-101 5.2.1.1 Single-point information without time tag.
     *
     *	Элемент информации - один бит ТС с описателем качества без метки времени.
     *	Тип блока данных \b <1> может иметь как первую структуру - последовательность
     *	из \b i одноэлементных объектов, так и втроую - один объект, содержащий
     *	\b j элементов.
     *
     *	Элемент информации - один байт следующей структуры: \a Siq.
     *
     *	Последовательность объектов информации (SQ = 0):
     *	- Идентификатор блока данных:
     *		- Идентификатор типа;
     *		- Классификатор переменной структуры;
     *		- Причина передачи;
     *		- Общий адрес ASDU.
     *	- Объект информации 1:
     *		- Адрес объекта информации;
     *		- Одноэлементная информация с описателем качества \a Siq;
     *	...
     *	- Объект информации 1:
     *		- Адрес объекта информации;
     *		- Одноэлементная информация с описателем качества \a Siq;
     *
     *	@see asduCommon
     *	@see DataUnitIdentifier
     *	@see Siq
     */
    typedef struct __attribute__((__packed__))
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
        SSiq        siq;  ///< Одноэлементная информация с описателем качества.
    } SMSpNa1;

    /**	\brief Одноэлементная информация с меткой времени СР56Время2а.
     *
     * 	Идентификатор типа = 30.
     *
     *	\note МЭК 870-5-101 7.3.1.22 Идентификатор типа 30: M_SP_TB_1.
     *	\note IEC 870-5-101 5.2.1.11 Single-point information with time tag CP56Time2a.
     *
     * 	Отличается от типа 1, \a MSpNa1, наличием 7-байтной метки времени. Он
     * 	может иметь только первую структуру - последовательность из i одноэлементных
     * 	объектов.
     *
     *	Последовательность объектов информации (SQ = 0):
     *	- Идентификатор блока данных:
     *		- Идентификатор типа;
     *		- Классификатор переменной структуры;
     *		- Причина передачи;
     *		- Общий адрес ASDU.
     *	- Объект информации 1:
     *		- Адрес объекта информации;
     *		- Одноэлементная информация с описателем качества;
     *		- Семь байт времени в формате СР56Время2а.
     *	...
     *	- Объект информации 1:
     *		- Адрес объекта информации;
     *		- Одноэлементная информация с описателем качества;
     *		- Семь байт времени в формате СР56Время2а.
     */
    typedef struct __attribute__((__packed__))
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
        SSiq        siq;  ///< Одноэлементная информация с описателем качества.
        SCp56Time2a cp56time2a;  ///< Метка времени "Время 2а в двоичном коде" CP56time2a.
    } SMSpTb1;

    /**	\brief Окончание инициализации (End of initialisation).
     *
     * 	Индентификатор типа = 70.
     *
     *	\note МЭК 870-5-101 7.3.3.1 Идентификатор типа 70: M_EI_NA_1.
     *	\note IEC 870-5-101 5.2.3.1 End of initialisation.
     *
     * 	В блоке данных передается один объект информации - информация о конце
     * 	инициализации на вторичной станции. Адрес объекта информации равен нулю,
     * 	т.е. адрес не используется.
     *
     * 	Объект информации содержит один информационный байт \a Coi - причина
     * 	инициализации.
     *
     * 	Одиночный объект информации (SQ = 0):
     * 	- Идентификатор блока данных:
     *		- Идентификатор типа;
     *		- Классификатор переменной структуры;
     *		- Причина передачи;
     *		- Общий адрес ASDU.
     *	- Объект информации:
     *		- Адрес объекта информации;
     *		- Причина инициализации (COI).
     */
    typedef struct __attribute__((__packed__))
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
        SCoi        coi;                       ///< Причина инициализации.
    } SMEiNa1;

    /**	\brief Команда опроса (Interrogation command).
     *
     * 	Идентификатор типа = 100.
     *
     *	\note МЭК 870-5-101 7.3.3.1 Идентификатор типа 100: C_IC_NA_1.
     *	\note IEC 870-5-101 5.2.4.1 Interrogation command.
     *
     * 	В блоке данных передается один объект информации - команда группового
     * 	запроса данных. Адрес объекта информации равен нулю. Объект информации
     * 	содержит один информационный байт \a Qoi - описатель запроса.
     *
     * 	Одиночный объект информации (SQ = 0):
     * 	- Идентификатор блока данных:
     *		- Идентификатор типа;
     *		- Классификатор переменной структуры;
     *		- Причина передачи;
     *		- Общий адрес ASDU.
     *	- Объект информации:
     *		- Адрес объекта информации;
     *		- Указатель опроса (QOI).
     */
    typedef struct __attribute__((__packed__))
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
        SQoi        qoi;                       ///< Указатель опроса.
    } SCIcNa1;

    /**	\brief Команда синхронизации часов (Clock synchronisation command).
     *
     * 	Идентификатор типа = 103.
     *
     *	\note МЭК 870-5-101 7.3.4.4 Идентификатор типа 103: C_CS_NA_1.
     *	\note IEC 870-5-101 5.2.4.2 Clock synchronisation command.
     *
     * 	В блоке данных передается один объект информации - команда синхронизации
     * 	часов. Адрес объекта информации равен нулю. Данными (не меткой времени)
     * 	передаваемого объекта информации является значение времени в двоичном
     * 	формате 7 байт (\a Cp56Time2a).
     *
     *	Одиночный объект информации (SQ = 0):
     * 	- Идентификатор блока данных:
     *		- Идентификатор типа;
     *		- Классификатор переменной структуры;
     *		- Причина передачи;
     *		- Общий адрес ASDU.
     *	- Объект информации:
     *		- Адрес объекта информации;
     *		- Семь байт времени в формате СР56Время2а.
     *
     *	При получении нового времени, оно помещается в буфер \a #stTime. Затем,
     *	при вызове функции \a getTime() в даный буфер будет записано время вызова
     *	функции. При следующем запросе данных класса 1 (2), в первичную станцию
     *	будет передан кадр об окончании синхронизации с временем вторичной
     *	станции во время синхронизации.
     */
    typedef struct __attribute__((__packed__))
    {
        SDataUnitId dataUnitId;  ///< Идентификатор блока данных.
        uint16_t    informationObjectAddress;  ///< Адрес объекта информации.
        SCp56Time2a cp56Time2a;  ///< Метка времени "Время 2а в двоичном коде" CP56time2a.
    } SCCsNa1;

    /**	\brief Обобщенная структура ASDU.
     *
     */
    typedef union __attribute__((__packed__))
    {
        SAsduCommon common;  ///< Данные, общие для всех команд.
        SMSpNa1 mSpNa1;  ///< Одноэлементная информация без метки времени.
        SMSpTb1 mSpTb1;  ///< Одноэлементная информация с меткой времени СР56Время2а.
        SMEiNa1 mEiNa1;  ///< Окончение инициализации.
        SCIcNa1 cIcNa1;  ///< Команда опроса
        SCCsNa1 cCsNa1;  ///< Команда синхронизации часов.
    } UAsdu;

    /** \struct SFrameFixLength
     * 	\brief Формат кадра с постоянной длиной.
     *
     *	Пользовательских данных нет.
     *
     * 	\var SFrameFixLength::startCharacter
     * 		Должно быть равно \a FRAME_FIX_LENGHT.
     *
     *	\var SFrameFixLength::controlField
     *		Cодержит информацию о направлении сообщения, типе сервиса и обеспечивает
     *		защиту от потерь и дублирования сообщений. При передаче от первичной
     *		станции к вторичной поле имеет вид \a CotrolFieldPrimary, при передаче
     *		от вторичной к первичной - \a ControlFieldSecondary.
     *
     *	\var SFrameFixLength::linkAddress
     *		Адрес передается от первичной станции к приемной и определяет адрес
     *		места назначения информации. Если равен \a #s_u8AddressGlb, то это общий
     *		кадр и ответа на него не требуется. Диапазон значений от \a #s_u8AddressMin
     *		до \a #s_u8AddressMax.
     *
     *	\var SFrameFixLength::checkSum
     *		В данном случае это поле управления + поле адреса.
     *
     *	\var SFrameFixLength::stopCharacter
     *		Должно быть равно \a #s_u8FrameStopCharacter.
     *
     *	@see CotrolFieldPrimary
     *	@see ControlFieldSecondary
     *	@see ADDRESS_MIN
     *	@see ADDRESS_MAX
     *	@see ADDRESS_GLB
     * 	@see FRAME_FIX_LENGHT
     * 	@see FRAME_STOP_CHARCTER
     */
    typedef struct __attribute__((__packed__))
    {
        uint8_t       startCharacter;  ///< Байт начала сообщения.
        UControlField controlField;    ///< Поле управления.
        uint8_t       linkAddress;     ///< Поле адреса (link).
        uint8_t checkSum;  ///< Контрольная сумма пользовательских данных.
        uint8_t stopCharacter;  ///< Слово окончания сообщения.
    } SFrameFixLength;

    /**	\struct SFrameVarLength
     * 	\brief Формат кадра с переменной длиной.
     *
     * 	\var SFrameVarLength::startCharacter
     * 		Должно быть равно \a #EFrameStartCharacter.
     *
     *	\var SFrameVarLength::length1
     *		По МЭК от 0 до 255. В данном случае не более размера буфера
     *		\a #m_u8Size минус 6 байт.
     *
     *	\var SFrameVarLength::length2
     *
     *	\var SFrameVarLength::startCharacter2
     *		Должно быть равно \a #EFrameStartCharacter.
     *
     *	\var SFrameVarLength::controlField
     *		Содержит информацию о направлении сообщения, типе сервиса и обеспечивает защиту от
     *потерь и дублирования сообщений. При передаче от первичной станции к вторичной поле имеет вид
     *\a ControlFieldPrimary, при передаче от вторичной к первичной \a ControlFieldSecondary.
     *
     *	\var SFrameVarLength::linkAddress
     *		Адрес передается от первичной станции к приемной и
     *		определяет адрес места назначения информации. Если равен \a #s_u8AddressGlb,
     *		то это общий кадр и ответа на него не требуется. Диапазон значений от
     *		\a #s_u8AddressMin до \a #s_u8AddressMax.
     *
     *	\var SFrameVarLength::asdu
     *		\a Asdu.
     *
     *	\var SFrameVarLength::checkSum
     *		Сумма по модулю 256. В данном случае это поле управления + поле адреса
     *		 + пользовательские данные \a #asdu.
     *
     *	\var SFrameVarLength::stopCharacter
     *		Должено быть равено \a #s_u8FrameStopCharacter.
     */
    typedef struct __attribute__((__packed__))
    {
        uint8_t startCharacter;  ///< Cлово начала сообщения.
        uint8_t length1;         ///< Длина пользовательских данных.
        uint8_t length2;  ///< лина пользовательских данных (повтор)
        uint8_t startCharacter2;     ///< Слово начала сообщения.
        UControlField controlField;  ///< Поле управления.
        uint8_t       linkAddress;   ///< Поле адреса (link).
        UAsdu         asdu;  ///< Блок данных прикладного уровня (пользовательские данные).
        uint8_t checkSum;  ///< Контрольная сумма пользовательских данных.
        uint8_t stopCharacter;  ///< Слово окнончания сообщения.
    } SFrameVarLength;

public:
    /** Состояния работы протокола.
     *
     * 	\attention
     * 	#STATE_OFF - всегда должен стоять в начале перечисления.
     *
     * 	\attention
     * 	#STATE_ERROR - всегда должен стоять в конце перечисления.
     *
     */
    typedef enum __attribute__((__packed__))
    {
        STATE_OFF = 0,  ///< \b <0> Протокол выключен.
        // ^^^ - всегда вначале
        STATE_READ        = 1,  ///< \b <1> Идет чтение посылки.
        STATE_READ_ERROR  = 2,  ///< \b <2> Ошибка в принятом пакете.
        STATE_READ_OK     = 3,  ///< \b <3> Посылка принята.
        STATE_WRITE_WAIT  = 4,  ///< \b <4> Ожидание нужных данных.
        STATE_WRITE_READY = 5,  ///< \b <5> Посылка готова к отправке
        STATE_WRITE       = 6,  ///< \b <6> Идет отправка посылки.
        // vvv - всегда в конце
        STATE_ERROR = 7  ///< \b <7> Ошибка в работе протокола.
    } EState;

    /// Ошибки проверки принятого кадра.
    typedef enum __attribute__((__packed__))
    {
        ERROR_NO          = 0,  ///< Ошибок нет.
        ERROR_SIZE_FRAME  = 1,  ///< Ошибка размера принятого кадра.
        ERROR_START2_CHAR = 2,  ///< Ошибка второго старт байта.
        ERROR_LENGHT1   = 3,  ///< Ошибка первого байта кол-ва данных.
        ERROR_LENGHT2   = 4,  ///< Ошибка второго байта кол-ва данных.
        ERROR_STOP_CHAR = 5,  ///< Ошибка стопового байта.
        ERROR_CRC       = 6,  ///< Ошибка контрольной суммы.
        ERROR_LINK_ADDRESS = 7,  ///< Ошибка адреса устройства.
        ERROR_PRM_BITE     = 8,  ///< Ошибка бита первичного сообщения.
        ERROR_COMMON       = 9   ///< Ошибка общая.
    } EError;

    ///	\brief Элемент информации.
    typedef struct
    {
        bool        send;  ///< True - данные готовы для передачи.
        bool        val;   ///< Значение.
        uint16_t    adr;   ///< Адрес.
        SCp56Time2a time;  ///< Время.
    } SEI;

    /// Время полученное от первичной станции.
    SCp56Time2a stTime;

    /**	Контструктор.
     *
     *	Изначально протокол ожидает сброса, т.е. текущая функция
     *	\a #FUNCTION_RESET_WAIT.
     *
     * 	@param[in] pBuf Буфер данных.
     * 	@param[in] u8Size Размер буфера данных.
     */
    CIec101(uint8_t *pBuf, uint8_t u8Size);

    /**	Возвращает адрес устройтсва в протоколе по-умолчанию, т.е. ошибка.
     *
     * 	@return Адрес устройства - ошибка.
     */
    uint8_t getAddressError() const { return s_u8AddressErr; }

    /**	Возвращает минимальный адрес устройства, доступный в протоколе.
     *
     * 	@return Адрес устройства - минимальный.
     */
    uint8_t getAddressMin() const { return s_u8AddressMin; }

    /**	Возвращает максимальный адрес устройства, досупный в протоколе.
     *
     * 	@return Адрес устройства - максимальный.
     */
    uint8_t getAddressMax() const { return s_u8AddressMax; }

    /**	Возвращает глобальный адрес.
     *
     * 	@return Глобальный адрес.
     */
    uint8_t getAddressGlb() const { return s_u8AddressGlb; }

    /**	Запуск работы данного протокола.
     *
     */
    void setEnable() { setState(STATE_READ); }

    /**	Остановка работы данного протокола.
     *
     *	Текущая функция утсанавливается в ожидание сброса \a #FUNCTION_RESET_WAIT.
     */
    void setDisable()
    {
        m_u8Func = FUNCTION_RESET_WAIT;
        setState(STATE_OFF);
    }

    /** Проверка текущего состояния работы данного протокола
     *
     *	@retval True - если протокол включен.
     *	@retval False - если протокол отключен.
     */
    bool isEnable() const { return (m_eState != STATE_OFF); }

    /**	Смена состояния на ожидание новой посылки.
     *
     */
    void setReadState() { setState(STATE_READ); }

    /**	Проверка наличия принятой посылки.
     *
     * 	@retval True - при наличии принятой посылки.
     * 	@retval False - при отсутствии принятой посылки
     */
    bool isReadData() const { return (m_eState == STATE_READ_OK); }

    /**	Смена состояния работы протокола.
     *
     *	Вынесена в public только для возможности тестирования работы класса!!!
     *
     *	В случае ошибочного значения, протокол останется в текущем состоянии.
     *
     *	При смене состояния на "Чтение", происходит обнуление счетчика принятых
     *	байт данных и времени прошедшего с момента приема последнего байта.
     *
     * 	@param[in] state Новое состояние работы протокола.
     */
    void setState(CIec101::EState state);

    /**	Проверка совпадения нужного состояния с текущим.
     *
     *	@param[in] state Проверяемое состояние.
     * 	@retval True - если протокол в нужном состоянии.
     * 	@retval False - если состояние протокола отличается от нужного.
     */
    bool checkState(CIec101::EState state) const { return (m_eState == state); }

    /**	Возвращает текущее состояние протокола.
     *
     *	Вынесена в public только для возможности тестирования работы класса!!!
     *
     *	@return Текущее состояние протокола.
     */
    CIec101::EState getState() const { return m_eState; }

    /**	Принятый байт данных.
     *
     *	При переполнении буфера байт будет просто проигнорирована.
     *
     *	Производится сброс счетчика времени, прошедшего с момента прихода
     *	последнего байта.
     *
     *	@param[in] u8Byte Байт данных.
     *	@return Возвращает кол-во принятых данных в буфере.
     */
    uint8_t push(uint8_t u8Byte);

    /** Возвращает кол-во байт в принятой посылке или готовых к отправке.
     *
     *	Используется для тестов.
     *
     * 	@return Кол-во байт данных.
     */
    uint8_t getNumOfBytes() const { return m_u8Cnt; }

    /**	Настройка счетчика времени.
     *
     * 	Исходя из полученной скорости работы протокола, наличия контроля
     * 	четности и кол-ва стоп-битов, а так же частоты вызова функции \a tick(),
     * 	рассчитывается шаг счета. При этом принимается кол-во "бит данных"
     * 	всегда 8, а кол-во бит "контроль четности" + "стоп-биты" равно 2.
     *
     * 	Например:
     * 	для скорости  19200 и частоте вызова функции 1 раз в 50мкс, получим:
     *
     *	step = (11 * 1.5 * 10^6) / (\a u8Period * \a u16Baudrate) = 17
     * 	,где	11 - кол-во бит для передачи одного байта данных;
     * 			1.5 - пауза до обнаружения окончания кадра, в байтах данных;
     * 			10^6 - перевод в мкс, т.к u8Period в мкс.
     *
     * 	Рассчитывается время передачи кадра синхронизации времени от сервера
     * 	до ПИ в мс.
     *
     *	Например:
     *	для скорости 19200 получим:
     *	delay = (11 * 21 * 10^3) / (\a u16Baudrate) = 12 мс
     *	,где	11 - кол-во бит для передачи одного байта данных;
     *			21 - кол-во байт данных в кадре синхронизации времени;
     *			10^3 - перевод в мс.
     *
     *	Запоминается частота вызова функции \a tick().
     *
     *	@param[in] baudrate Скорость работы последовательного порта, бит/с.
     *	@param[in] period Частота вызова функции \a tick(), мкс.
     *	@return Рассчитанный шаг счетчика.
     */
    uint16_t setTick(uint16_t baudrate, uint8_t period);

    /**	Счет времени прошедшего с момента прихода последнего байта.
     *
     *	Счетчик считает всегда.
     *
     *	Как только счетчик времени достигнет (превысит) \a # m_u16TickTime, т.е.
     *	будет обнаружен необходимый интервал спокойного состояния в 1.5 байта:
     *	- в состоянии \a #STATE_READ необходимо не менее 5 принятых байт  для
     *	перехода в состояние принятой посылки \a #STATE_READ_OK, иначе
     *	снова будет установлено \a #STATE_READ.
     *	В состоянии \a #STATE_READ_ERROR идет ожидание требуемого интервала
     *	спокойного состояния (2 * \a #m_u16TickTime или 3 байта), а затем переход
     *	в \a #STATE_READ (т.е. ожидание новой посылки).
     *
     * 	\attention Вызывается с заданной в \a setTick() частотой, например, из
     * 	прерывания.
     */
    void tick();

    /**	Возвращает задержку времени.
     *
     * 	Задержка состоит из трех основных составляющих:
     * 	- время передачи от сервера до БСП-ПИ, зависит от скорости порта;
     * 	- время прошедшее с момента приема кадра от сервера, до момента отправки
     * 	в БСП;
     * 	- время передачи от БСП-ПИ до БСП, фиксировано (зависит от настроек порта).
     *
     */
    uint16_t getDelay() const;

    /**	Установка адреса устройства в сети.
     *
     *	В случае ошибочного значения, смены адреса не происходит.
     *
     * 	@param[in] u8Adr Адрес устройства.
     * 	@retval True - в случае смены адреса устройства.
     * 	@retval False - в случае ошибочного адреса.
     */
    bool setAddressLan(uint8_t u8Adr);

    /**	Возвращает адрес устройства в сети.
     *
     * 	@return Адрес устройства.
     */
    uint8_t getAddressLan() const { return m_u8Address; }

    /**	Отправка сообщения.
     *
     *	В случае, если состояние отличается от состояния готовности к передаче
     *	\a #STATE_WRITE_READY, количество байт данных на передачу будет равно 0.
     *	При наличии данных для передачи состояние изменится на \a #STATE_WRITE.
     *
     *	Флаг наличия сообщения
     *
     * 	@return Кол-во байт данных для передачи.
     */
    uint8_t sendData();

    /**	Обработка принятых данных.
     *
     *	В зависимости от обнаруженных ошибок в принятом пакете состояние изменится
     *	на ошибочное \a #STATE_READ_ERROR. При котором следует дождаться определенного
     *	интервала спокойного состояния на линии.
     *
     *	Формируется ответ. При наличии готового ответа состояние изменяется на
     *	\a #STATE_WRITE_READY.
     */
    void readData();

    /**	Возвращает текущее состояние флага сброса протокола.
     *
     *	Функция введена для удобства тестирования.
     *
     * 	@retval True - протокол сброшен и находится в рабочем состоянии.
     * 	@retval False - протокол ожидает сброса.
     */
    bool isReset() const { return !(m_u8Func & FUNCTION_RESET_WAIT); }

#ifdef MY_TESTS
    /**	Установка флага наличия сообщений класса 1 (2).
     *
     * 	Используется только для тестирования.
     */
    uint8_t class2;
    void    sendClass2() { class2 = 4; }

    uint8_t class1;
    void    sendClass1() { class1 = 2; }

#endif


private:
    const uint8_t  m_u8Size;  ///< Размер буфера данных
    uint8_t *const m_pBuf;    ///< Буфер принятых/передаваемых данных

    EState  m_eState;     ///< Текущее состояние работы протокола.
    uint8_t m_u8Address;  ///< Адрес устройства в сети.
    volatile uint8_t  m_u8Cnt;  ///< Кол-во принятых байт.
    volatile uint16_t m_u8Tick;  ///< Время прошедшее с момента приема последнего байта.
    uint8_t  m_u8TickPeriod;  ///< Частота вызова функции \a tick() в мкс.
    uint16_t m_u16TickTime;   ///< Шаг счета паузы.
    uint16_t m_u16DelayPc;    ///< Задержка передачи кадра от сервера.


    uint8_t m_u8Func;  ///< Флаги текущих функций протокола (\a #EFunction).
    uint8_t m_u8Fcb;  ///< Ожидаемый бит счета кадров. <0> или <1>.

    bool            m_bInterrog;  ///< Флаг необходимости отправки сообщений опроса.
    SCp56Time2a     m_stCp56time2a;  ///< Хранилище времени.
    SFrameFixLength m_stFrameFix;    ///< Кадр фиксированной длины.
    SFrameVarLength m_stFrameVar;    ///< Кадр переменной длины.
    EFrameStartCharacter m_eFrameSend;  ///< Кадр подготовленный для передачи.

    SEI ei1;  /// Элемент информации класса 1 для отправки.
    SEI ei2;  /// Элемент информации класса 2 для отправки.

    /**	Проверка необходимости передать новое сообщении класса 1.
     *
     *	Флаг наличия данных для передачи устанавливается, если:
     *	- Установлена функция текущего состояния - опрос (iterrogation);
     *	- Имеются данные класса 1 на передачу.
     *
     *	@retval 0 Нет данных на передачу.
     *	@retval 1 Есть данные на передачу.
     */
    uint8_t isAcd();

    /**	Проверка бита счета кадров.
     *
     *	@param[in] rCf Поле управления при передаче от первичной станции к вторичной.
     * 	@retval False Бит не соответствует ожиданиям. Ошибка.
     * 	@retval True Бит соответствует ожиданиям. Все норм.
     */
    bool checkFcb(SControlFieldPrimary &rCf) const { return (!rCf.fcv) || (rCf.fcb == m_u8Fcb); }

    /**	Установка активной функции протокола.
     *
     * 	@param[in] func Функция протокола.
     */
    void setFunc(EFunction func) { m_u8Func |= func; }

    /**	Сброс активной функции протокола.
     *
     * 	@param[in] func Функция протокола.
     */
    void clrFunc(EFunction func) { m_u8Func &= ~func; }

    /**	Проверка активности функции протокола.
     *
     * 	@param[in] func Проверяемая функция протокола.
     * 	@retval True Функция протокола активна.
     * 	@retval False Фунция протокола не активна.
     */
    bool isFunc(EFunction func) const { return (m_u8Func & func); }

    /** Подсчет контрольной суммы для кадра с фиксированной длиной.
     *
     *	@param[in] rFrame Кадр с фиксированной длиной.
     * 	@return Контрольную сумму в кадре.
     */
    uint8_t getCrcFixFrame(SFrameFixLength &rFrame) const;

    /**	Подсчет контрольной суммы для кадра с переменной длиной.
     *
     * 	Для рассчета КС используется первое поле длины пользовательских данных.
     *
     *	@param[in] rFrame Кадр с переменной длиной.
     * 	@return Контрольную сумму в кадре.
     */
    uint8_t getCrcVarFrame(SFrameVarLength &rFrame) const;

    /**	Проверка кадра с фиксированной длиной.
     *
     *	Возвращает 0, если ошибок нет.
     *
     *	@param[in] rFrame Кадр с фиксированной длиной.
     * 	@return Код ошибки, в случае ее наличия (\a #EError)
     */
    CIec101::EError checkFrameFixLenght(SFrameFixLength &rFrame) const;

    /**	Проверка принятого кадра.
     *
     * 	В зависимости от обнаруженных ошибок в принятом пакете состояние изменится
     *	на ошибочное \a #STATE_READ_ERROR. При котором следует дождаться определенного
     *	интервала спокойного состояния на линии.
     *
     * 	@return Код ошибки, в случае ее наличия (\a #EError)
     */
    CIec101::EError checkFrame();

    /** Проверка кадра с переменной длиной.
     *
     *	Возвращает 0, если ошибок нет.
     *
     *	@param[in] rFrame Кадр с переменной длиной.
     * 	@return Код ошибки, в случае ее наличия (\a #EError)
     */
    CIec101::EError checkFrameVarLenght(SFrameVarLength &rFrame) const;

    /**	Обработка кадра с фиксированной длиной.
     *
     *	Если ответа не требуется, будет осуществлен переход в ожидание следующего
     *	кадра.
     *
     *	\attention Изначально ожидаются кадры сброса от первичной станции, до их
     *	прихода все отсальные кадры игнорируются.
     *
     *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
     *	unbalanced transmission systems.
     *
     *	@param[in] rFrame Кадр с фиксированной длиной.
     */
    void readFrameFixLenght(SFrameFixLength &rFrame);

    /**	Обработка кадра с переменной длиной.
     *
     *	\attention Изначально ожидаются кадры сброса от первичной станции, до их
     *	прихода все отсальные кадры игнорируются.
     *
     *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
     *	unbalanced transmission systems.
     *
     *	@param[in] rFrame Кадр с переменной длиной.
     */
    void readFrameVarLenght(SFrameVarLength &rFrame);

    /**	Отправка подготовленного кадра.
     *
     * 	Состояние изменяется на \a #STATE_WRITE_READY.
     */
    void sendFrame();

    /**	Отправка кадра с фиксированной длиной.
     *
     *	Отправлен будет последний подготовленный кадр, переменной или постоянной
     *	длины.
     *
     *	Состояние изменяется на \a #STATE_WRITE_READY.
     */
    void sendFrameFixLenght();

    /**	Отправка кадра с переменной длиной.
     *
     * 	Сформированный кадр (\a prepareFrameVarLenght())  уже лежит в \a frameVar_.
     *
     *	В буфер передачи сначала копируется заголовок (4 байта) и пользовательские
     *	данные (зависит от идентификатора типа).
     *
     *	Проверяется наличие данных класса 1 на передачу, и если они есть
     *	утсанавливается бит требования запроса данных.
     *
     *	Затем подсчитывается КС и добавляется стоп-байт.
     *
     * 	Состояние изменяется на \a #STATE_WRITE_READY.
     */
    void sendFrameVarLenght();

    /**	Подготовка кадра с постоянной длиной к отправке.
     *
     * 	Формируется кадр фиксированной длины с полем управления содержащим
     *	функциональный код \a function и бит требования запроса данных  \a acd.
     *
     *	Состояние изменяется на \a #STATE_WRITE_READY.
     *
     *	@see ControlFieldSecondary
     *	@param[in] eFunction Функциональный код.
     */
    void prepareFrameFixLenght(EFcSecondary eFunction);

    /**	Подготовка кадра с переменной длиной к отправке.
     *
     *	В блоке данных прикладного уровня (ASDU) заполняются только поля
     *	идентификатора блока данных. Остальное должно быть подготовлено заранее.
     *
     *	После подготовки кадра устанавливается флаг наличия подготовленного
     *	сообщения класса 1 \a #m_bAcd.
     *
     *	В классификатор переменной структуры всегда пишется \a #s_u8VariableStructureQualifier,
     *	что означает что число передаваемых ОБЪЕКТОВ ИНФОРМАЦИИ всегда равно 1.
     *
     *	@param[in] eId Идентификатор типа.
     *	@param[in] eCot Причина передачи.
     *	@param[in] u8SizeAsdu Длина пользовательских данных.
     */
    void prepareFrameVarLenght(ETypeId eId, ECot eCot, uint8_t u8SizeAsdu);

    /**	Подготовка кадра одноэелементной информации без метки времени.
     *
     *	Все элементы \a SSiq, за исключением значения элемента, обнуляются.
     *
     *	@param[in] u16Address Адрес объекта информации.
     *	@param[in] eCause Причина передачи \a #ECot.
     *	@param[in] bVal Передаваемое значение.
     */
    void prepareFrameMSpNa1(uint16_t u16Address, ECot eCause, bool bVal);

    /**	Подготовка кадра окончания инициализации.
     *
     *	@param[in] eCause Причина инициализации \a #ECoi.
     */
    void prepareFrameMEiNa1(ECoi eCause);

    /**	Подготовка кадра опроса.
     *
     *	Указатель опроса всегда передается \a #QOI_NOT_USED.
     *
     *	Адрес объекта информации равен нулю.
     *
     *	@param[in] eCause Причина передачи \a #ECot.
     */
    void prepareFrameCIcNa1(ECot eCause);

    /**	Подготовка кадра синхронизации времени (окончание).
     *
     *	Производится копирование времени аппарата на момент установки нового.
     *
     * 	@param[in] eCause Причина передачи \a #ECot.
     */
    void prepareFrameCCsNa1(ECot eCause);

    /**	Обработка кадра фиксированной длины с функцией запроса данных класса 1 и 2.
     *
     *	Проверяется наличие текущих функций протокола (\a #m_u8Func) по порядку:
     *	- \a #FUNCTION_RESET_END - отправяется кадр окончания сброса, при условии
     *	что бит счета кадров равен 1;
     *	- Если принятый бит счета кадров не равен ожидаемому повторно передается
     *	предыдущий кадр;
     *	- \a #FUNCTION_TIME_SYNCH_CONF - проверяется наличие времения для отправки
     *	кадра окончания синхронизации времени, с мектой локального времени в
     *	момент синхронизации;
     *	- \a #FUNCTION_INTERROG_CONF - отправляется кадр подтверждения начала
     *	опроса;
     *	- \a #FUNCTION_INTERROG_MONIT - отправляется кадр с данными опроса, либо
     *	кадр окончания опроса.
     *	- проверяется наличие данных класса 1 и 2 на передачу, если они есть -
     *	идет их отправка, иначе передается кадр NACK.
     *
     * 	@param[in] rFrame Кадр с фиксированной длиной.
     */
    void procFrameFixLenghtUserData(SFrameFixLength &rFrame);

    /**	Обработка принятого кадра с переменной длиной.
     *
     *	@param[in] asdu Принятый блок данных.
     *	@retval True Кадр обработан.
     * 	@retval False Кадр не обработан.
     */
    bool procFrameVarLenght(UAsdu asdu);

    /**	Проверка наличия данных класса 1 на передачу.
     *
     *	@param adr[out] Адрес.
     *	@param val[out] Значение.
     *	@param time[out] Дата и время.
     * 	@retval False Нет данных на передачу.
     * 	@retval True Есть данные на передачу.
     */
    virtual bool checkEventClass1(uint16_t &adr, bool &val, SCp56Time2a &time);

    /**	Проверка наличия данных класса 2 на передачу.
     *
     *	@param adr[out] Адрес.
     *	@param val[out] Значение.
     *	@param time[out] Дата и время.
     * 	@retval False Нет данных на передачу.
     * 	@retval True Есть данные на передачу.
     */
    virtual bool checkEventClass2(uint16_t &adr, bool &val, SCp56Time2a &time);

    /**	Отправка события класса 1.
     *
     *	@retval True Подготовлены данные для передачи.
     *	@retval False Данных нет.
     */
    bool procEventClass1();

    /**	Отправка события класса 2.
     *
     * 	@retval True Подготовлены данные для передачи.
     *	@retval False Данных нет.
     *
     */
    bool procEventClass2();

    /**	Обработка ответа на команду опроса.
     *
     *	При корректном адресе подготавливается кадр C_IC_NA_1 и возвращается \a
     *	True, иначе False.
     *
     *	В данной функции возвращаются:
     *	- адреса 201, 202 = false;
     *	- адреса 203, 204 = true;
     *
     *	@param adr[out] Адрес.
     *	@param val[out] Значение.
     *	@retval True Подготовлены данные для передачи.
     *	@retval False Данных нет.
     */
    virtual bool procInterrog(uint16_t &adr, bool &val);

    /**	Установка времени.
     *
     *	Вызывается автоматически, при получении кадра синхронизации времени.
     *
     *	При вызове формируется метка времени:
     *	4.05.06 03:02:01.000
     *
     * 	@retval True Время установлено.
     * 	@retval False Время не установлено.
     */
    virtual bool procSetTime() { return true; }

    /**	Наличие полученного времени в момент синхронизации.
     *
     * 	Вызывается автоматически при принятии пакетов фиксированой длины, просле
     * 	кадра синхронизации времени.
     *
     *	При вызове формируется метка времени:
     *	4.05.06 03:02:01.000
     *
     * 	@retval bool True Время в момент синхронизации получено.
     * 	@retval bool False Времени для ответа нет.
     */
    virtual bool procSetTimeEnd();

    /**	Обработка принятого кадра синхронизации часов.
     *
     *	Кадр синхронизации часов будет обработан, если:
     *	- принятая причина передачи "Активация" (\a #COT_ACT).
     *
     *	В ответ будет сформирован кадр фиксированной длины \a #CONFIRM_ACK. А по
     *	завершению синхронизации кадр переменной длины \a #TYPE_ID_C_CS_NA_1 c
     *	текущим временем до синхронизации и причиной "Завершенеи активации" (\a
     *	#COT_ACTCON).
     *
     *	К текущим функциям добавится \a #FUNCTION_TIME_SYNCH_CONF.
     *
     *	Производится вызов функции \a procSetTime(), в кторой по умолчанию
     *	происходит установка времени, т.е. вызов \a getTime().
     *
     * 	@param[in] stCCsNa1 Кадр синхронизации часов.
     * 	@retval True Кадр обработан.
     * 	@retval False Кадр не обработан.
     */
    bool procFrameCCsNa1(SCCsNa1 stCCsNa1);

    /**	Обработка принятого кадра опроса.
     *
     *	Кадр опроса будет обработан, если:
     *	- принятая причина передачи "Активация" (\a #COT_ACT).
     *
     *	В ответ будет сформирован кадр фиксированной длины \a #CONFIRM_ACK. А по
     *	завершению синхронизации кадр переменной длины \a #TYPE_ID_C_IC_NA_1 c
     *	причиной передачи "Завершение активации" (\a #COT_ACTTERM).
     *
     *	К текущим функциям добавится \a #FUNCTION_INTERROG_CONF.
     *
     *	Счетчик опроса будет сброшен.
     *
     *	@param[in] stCIcNa1 Кадр опроса.
     * 	@retval True Кадр обработан.
     * 	@retval False Кадр не обработан.
     */
    bool procFrameCIcNa1(SCIcNa1 stCIcNa1);

    /**	Копирование метки времени Cp56Time2a.
     *
     * 	Копирование ведется из \a rSource в \a rDist.
     *
     *	@param[out] rDist Куда копируется метка времени.
     *	@param[in] rSource Откуда копируется метка времени.
     */
    void copyCp56time2a(SCp56Time2a &rDist, const SCp56Time2a &rSource);

protected:
    /**	Подготовка кадра одноэелементной информации с меткой времени.
     *
     * 	Все эелементы \a SSiq, за исключением значения элемента, обнуляются.
     *
     * 	@param[in] u16Address Адрес объекта информации.
     *	@param[in] eCause Причина передачи \a #ECot.
     *	@param[in] bVal Передаваемое значение.
     *	@param[in] rTime Массив с текущим временем.
     */
    void prepareFrameMSpTb1(uint16_t u16Address, ECot eCause, bool bVal, SCp56Time2a &rTime);

    /**	Заполнение метки времени Cp56Time2a.
     *
     * 	@param[out] rTime Метка времени для заполнения
     * 	@param[in] years Год.
     * 	@param[in] months Месяц.
     * 	@param[in] day День месяца.
     * 	@param[in] hours Часы.
     * 	@param[in] min Минуты.
     * 	@param[in] sec Секунды.
     * 	@param[in] msec Миллисекунды.
     */
    void writeCp56Time2a(SCp56Time2a &rTime,
                         uint8_t      years,
                         uint8_t      months,
                         uint8_t      day,
                         uint8_t      hours,
                         uint8_t      min,
                         uint8_t      sec,
                         uint16_t     msec);
};

#endif /* CIEC101_H_ */
