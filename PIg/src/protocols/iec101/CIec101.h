/*
 * iec_60870_5_101.h
 *
 *  Created on: 21.04.2015
 *      Author: Shcheblykin
 */

#ifndef CIEC101_H_
#define CIEC101_H_

#include <stdint.h>
#ifdef AVR
	#include "debug.hpp"
#endif

#ifdef MY_TESTS
//	#include <stdio.h>
#endif

/**	\defgroup Notation Стиль оформления.
 *
 *	Префикс:
 *	- b - булева переменная, bError;
 *	- cl - класс, clIec101;
 *	- e - перечисление, eTypeId;
 *	- i8 - целочисленная переменная размером 8 бит, i8Error;
 *	- i16 - целочисленная переменная размером 16 бит, i16Error;
 *	- p - указатель, pArray;
 *	- r - ссылка, rArray;
 *	- s - строка в RAM, sDate;
 *	- sf - строка в FLASH, sfDate;
 *	- st - структура, SData;
 *	- u - объединение union, uAsdu;
 *	- u8 - беззнаковая переменная размером 8 бит, u8Size;
 *	- u16 - беззнаковая переменная размером 8 бит, u16Size;
 *	- v - отсутствие типа void, vReserved.
 *
 *	Префикс:
 *	- c_ - статическая переменная функции, c_u8Address.
 *	- g_ - глобальная переменная, g_u8Address;
 *	- m_ - переменная-член, m_u8Address;
 *	- s_ - статическая переменная-член, s_u8AddressMax;
 *
 *	Префикс:
 *	- C - класс, CIec101;
 *	- E - перечисление, ECot;
 *	- S - структура, SDate;
 *	- T - новый тип данных (typedef);
 *	- U - объединение, UAsdu.
 *
 *	Имена локальным переменным даются без данных префиксов.
 */

/** \defgroup Main МЭК 60870-5-101
 *
 */

/**	\defgroup Definitions Термины и определения
 *	\ingroup Main
 *
 *	- Асинхронный (старт-стопный) формат передачи - формат с обрамлением каждого
 *	символа длиной от 5 до 8 бит стартовым битом "0", опциональным битом четности
 *	(нечетности) и стоповым битом (двумя битами) "1". Интервалы между символами
 *	могут иметь произвольную длительность при состоянии линии "1".
 *
 *	- <b> Controlling Station </b> - первичная станция, которая может инициировать
 *	процедуру обмена информацией.
 *	- <b> Controlled Station </b> - вторичная станция, которая может передавать сообщения
 *	(данные или квитанции) только после запроса первичной станции.
 *
 *	- <b> Unbalanced transmission system </b> - небалансная передача, режим передачи,
 *	при котором только одна станция - первичная - может начинать передачу информации,
 *	а другая станция (все остальные при многоточечном канале) - вторичная -
 *	передает только после запроса первичной станции.
 *
 *	- \b ASDU - блок данных прикладного уровня (Application service data unit).
 *	- \b COI - причина инициализации (Cause of initialisation).
 *	- \b COT - причина передачи (Cause Of Transmission).
 *	- \b FC - функциональный код (Function code).
 *	- \b FCB - бит счета кадров (Frame count bit).
 *	- \b QOI - описатель запроса (Qualifier of interrogation).
 */

/**	\defgroup Frame Формат протокола FT1.2
 *	\ingroup Main
 *
 * 	В соответствии с ГОСТ Р МЭК 870-5-101 данный отраслевой протокол использует
 *	на канальном уровне только асинхронный протокол FT1.2. Формат слова 8Б1, т.е.
 *	8 информационных бит с контрольным битом проверки на четность (even) и одним
 *	стоп-битом.
 *
 *	Предусмотрено использование следующих видов информационных кадров:
 *	- кадр фиксированной длины;
 *	- кадр переменной длины;
 *	- однобайтовые посылки <b> CONTROL1 = E5h </b> и <b> CONTROL2 = A2h </b>
 *	(в данном случае не реализованы).
 *
 *	Кадры  пользовательских данных с <b> ФИКСИРОВАНОЙ ДЛИНОЙ </b> состоят из стартового
 *	слова, фисксированного числа L байтов пользовательских данных, контрольной
 *	суммы (КС) и слова окончания.
 *
 *	Правила передачи:
 *	- R1 - спокойное состояние линии - двоичная 1;
 *	- R2 - каждая комбинация содержит стартовый бит (двоичный 0), 8 информационных
 *	битов, один бит четности, один стоп-бит (двоичная 1);
 *	- R3 - между символами кадра не разрешается иметь интервалы спокойного состояния;
 *	- R4 - при определении ошибки в соответствии с правилом R6 требуется минимальный
 *	интервал между кадрами, равный 33 бит спокойного состояния линии;
 *	- R5 - последовательность слов пользовательских данных оканчивается контрольной
 *	суммой из 8 бит. Контрольная сумма - это арифметическая сумма, пренебрегающая
 *	переполнением (сумма по модулю 256) у всех байтов пользовательских данных;
 *	- R6 - приемник контролирует:
 *		- по слову:
 *			- старт-бит;
 *			- стоп-бит;
 *			- бит четности;
 *		- по кадру:
 *			- стартовое слово \b 0x10;
 *			- контрольную сумму кадра;
 *			- слово окончания \b 0x16;
 *		- При обнаружении ошибки контролируется интервал спокойного состояния
 *	линии, определяемый в соответствии с правилом R4.
 *
 *	Кадр бракуется, если хотя бы одна из проверок дает отрицательный результат.
 *	При положительных результатах проверок кадр выдается пользователю.
 *
 *	Кадры пользовательсих данных с <b> ПЕРЕМЕННОЙ ДЛИНОЙ </b> состояи из двух
 *	стартовых одинаковых слов (1-го и 4-ого слов), двух одинаковых слов, определяющих
 *	число L байтов пользовательских данных (2-го и 3-го слов), пользовательских
 *	данных, слова контрольной суммы кадра и одного слова окончания.
 *
 *	L - число от 0 до 255. выраженное в двоичном исчислении.
 *	Правила передачи:
 *	- R1, R2, R3, R4, R5 - см ждя кадра с фиксированной длиной;
 *	- R6 - приемник контролирует:
 *		- по слову:
 *			- стартовый бит;
 *			- стоп-бит;
 *			- бит четности;
 *		- по кадру:
 *			- стартовые слова в начале и конце загаловка кадра \b 0x68;
 *			- идентичность двух слов, характеризующих длину \b L;
 *			- число принимаемых слов равное <b> L + 6 </b>;
 *			- контрольную сумму кадра;
 *			- слово окончания \b 0x16;
 *		- При обнаружении ошибки контрлирует интервал спокойного состояния линии,
 *		определенный в соответствии с правилом R7.
 *
 *	Кадр бракуется, если хотя бы один из контролируемых элементов неправильный.
 *	При положительных результатах проверок кадр выдается пользователю.
 *
 *	\note МЭК 870-5-1-95 6.2.4.2.1 Формат FT1.2: кадоры с фиксированным числом
 *	байтов пользовательских данных.
 *	\note IEC 870-5-101 4 Standard frame format.
 */

/**	\brief Класс работы с протоколом МЭК 60870-5-101.
 *
 *	Для работы протокола необходимо:
 *	- переопределить виртуальные обработчики под свои данные;
 *	- вызывать функцию \a push() при принятии очередного байта данных, например
 *	в прерывании приема;
 *	- по покончанию передачи ответа вызвать функцию \a setReadState();
 *	- вызывать функцию \a tick() с заданным в функции \a setTick() периодом,
 *	например из прерывания таймера;
 *
 *	Для начала работы необходимо выполнить следующие шаги:
 *	- установить адрес устойства в сети 60870-5-101, например \a setAddress(42);
 *	- установить шаг счета паузы между принятыми данными, например для скорости
 *	19200 бит/с и периодом вызова функции \a tick() 50мкс \a setTick(19200, 50);
 *	- запустить протокол \a setEnable().
 *
 *	Для того чтобы не тратить времени на разбор посылки на "лету", ее окончание
 *	определяется по наличию интервала спокойного состояния более 1.5 символов.
 *
 *	При обнаружении ошибки приема по УАПП (например не совпал бит контроля четности),
 *	необходимо установить состояние \a #STATE_READ_ERROR.
 *
 *	Изначально, согласно протоколу, должны прийти сигналы сброса с первичной
 *	станции и только после этого протокол начинает работать в полном объеме.
 *
 *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
 *	unbalanced transmission systems.
 *
 *	Если в посылке будут обнаружены ошибки, то требуется в случае кадра
 *	фиксированной длины требуется интервал спокойного состояния не менее 33 бит,
 *	а для переменной - не менее 22 бит. Для упрощения всегда ждем 33 бита.
 *
 *	При обнаружении принятой посылки \a isReadData(), надо вызвать функцию
 *	\a readData().
 *
 *	Вызвать функцию передачи ответа \a sendData() и если она вернет не нулевое
 *	количество подготовленных для передачи байт, отправить их.
 *
 *	Общий адрес станции \a #s_u8CommonAddressOfAsdu.
 *
 *	Размер буфера для приема/передачи не должен превышать 255 байт.
 *
 * 	@see STATE
 */
class CIec101 {
#ifdef TEST_FRIENDS
	TEST_FRIENDS;
#endif

	/// Максимальное значение паузы между принятыми байтами в тиках
	static const uint16_t s_u16TickMax = 60000;		// при тике 50мкс, будет 3с

	/// Общий адрес ASDU.
	static const uint8_t s_u8CommonAddressOfAsdu = 1;

	/// Классификатор переменной структуры
	static const uint8_t s_u8VariableStructureQualifier = 1;

	/// Ошибочный адрес, устанавливается по-умолчанию.
	static const uint8_t s_u8AddressErr = 0;
	/// Минимальный адрес устройства в сети.
	static const uint8_t s_u8AddressMin = 1;
	/// Максимальный адрес устройства в сети (как и в MODBUS).
	static const uint8_t s_u8AddressMax = 247;
	/// Глобальный адрес.
	static const uint8_t s_u8AddressGlb = 255;

	/// Слово окончания.
	static const uint8_t s_u8FrameStopCharacter = 0x16;

	/// Размер кадра с постоянной длиной.
	static const uint8_t s_u8SizeOfFrameFixLenght = 5;

	/// Минимальный размер кадра с переменной длиной.
	static const uint8_t s_u8SizeOfFrameVarLenghtMin = 15;

protected:

	/**	\struct SCp56Time2a
	 * 	\brief Метка времени "Время 2а в двоичном коде" CP56time2a.
	 *
	 * 	\note
	 * 	В значении миллисекунд храняться также и секунды.
	 *
	 * 	\var SCp56Time2a::milliseconds
	 * 		UI16[1..16] <0..59999>
	 *
	 *	\var SCp56Time2a::minutes
	 *		 UI6[17..22] <0..59>
	 *
	 *	\var SCp56Time2a::res1
	 *		BS1[23]
	 *		\details Бит может использоваться в направлении контроля для указания,
	 * 		добавлена ли метка времени к объекту информации, когда он получен от RTU
	 * 		время), или метка времени установлена промежуточным оборудованием,
	 * 		таким как станция-концентратор, или самой контролирующей станцией
	 * 		(измененное время):
	 * 		- <0> - истинное время,
	 * 		- <1> - измененное время.
	 *
	 *	\var SCp56Time2a::iv
	 *		BS1[24] <0..1>
	 * 		- <0> - действительно,
	 * 		- <1> - недействительно.
	 *
	 * 	\var SCp56Time2a::hours
	 * 		UI5[25..29] <0..23>
	 *
	 * 	\var SCp56Time2a::res2
	 *		BS2[30..31]
	 *
	 *	\var SCp56Time2a::su
	 *		BS1[32] <0..1>
	 *		\details Бит летнего времени \a SU опционально используется как
	 * 		дополнительная информация для укзания, какое время (стандартное или
	 * 		летнее) действует в настоящий момент. Это может быть полезно для
	 * 		присвоения правильного времени объектам информации, генерируемым в
	 * 		течение первого часа после переключения со стандартного на летнее время:
	 * 		- <0> - стандартное время,
	 * 		- <1> - летнее время.
	 *
	 *	\var SCp56Time2a::dayOfMonth
	 *		UI5[33..37] <1..31>
	 *
	 *	\var SCp56Time2a::dayOfWeek
	 *		UI3[38..40] <1..7>
	 * 		- <0> - день недели не используется.
	 *
	 *	\var SCp56Time2a::months
	 *		UI4[41..44] <1..12>
	 *
	 *	\var SCp56Time2a::res3
	 *		BS4[45..48]
	 *
	 *	\var SCp56Time2a::years
	 * 		UI7[49..55] <0..99>
	 *
	 * 	\var SCp56Time2a::res4
	 * 		BS1[56]
	 */
	typedef struct __attribute__ ((__packed__)) {
		uint16_t milliseconds 	: 16;	///< Миллисекунды.
		uint8_t minutes 		: 6;	///< Минуты.
		uint8_t res1 			: 1;	///< Резерв 1 - RES1.
		uint8_t iv 				: 1;	///< Недействительно - IV.
		uint8_t hours 			: 5;	///< Часы.
		uint8_t res2 			: 2;	///< Резерв 2 - RES2.
		uint8_t su 				: 1;	///< Летнее время - SU .
		uint8_t dayOfMonth 		: 5;	///< День месяца.
		uint8_t dayOfWeek 		: 3;	///< День недели.
		uint8_t months 			: 4;	///< Месяцы.
		uint8_t res3 			: 4;	///< Резерв 3 - RES3.
		uint8_t years 			: 7;	///< Годы.
		uint8_t res4 			: 1;	///< Резерв 4 - RES4.
	} SCp56Time2a;

	/**	\brief Причина передачи (Сause of Transmission).
	 *
	 * 	\note МЭК 870-5-101-2006 7.2.3 Причина передачи.
	 *	\note IEC 870-5-101 4.2.8 Cause of transmission
	 */
	typedef enum __attribute__ ((__packed__)) {
		COT_NOT_USED	= 0,	///< \b <0> Не используется (not used).
		COT_PER_CYC	 	= 1,	///< \b <1> Периодически, циклически (per/cyc).
		COT_BACK		= 2,	///< \b <2> Фоновое сканирование (background scan).
		COT_SPONT		= 3,	///< \b <3> Спорадически (spontaneous).
		COT_INIT		= 4,	///< \b <4> Сообщение об инициализации (initialised).
		COT_REQ			= 5,	///< \b <5> Запрос или запрашиваемые данные (request or requested).
		COT_ACT			= 6,	///< \b <6> Активация (activation).
		COT_ACTCON		= 7,	///< \b <7> Подтверждение активации (activation confirmation).
		COT_DEACT		= 8,	///< \b <8> Деактивация (deactivation).
		COT_DEACTON		= 9,	///< \b <9> Подтверждение деактивации (deactivation confirmation).
		COT_ACTTERM		= 10,	///< \b <10> Завершенеи активации (activation termination).
		COT_RETREM		= 11,	///< \b <11> Обратная информация, вызванная удаленной командой (return information caused by a remote command).
		COT_RETLOC		= 12,	///< \b <12> Обратная информация, вызванная местной командой (return information caused by a local command).
		COT_FILE		= 13, 	///< \b <13> Передача файлов (file transfer).
		COT_INROGEN		= 20 	///< \b <20> Ответ на опрос станции (interrogated by general interrogation).
	} ECot;

private:

	///	Флаги текущих функций.
	typedef enum __attribute__ ((__packed__)) {
		FUNCTION_NO				= 0x00,	///< \b <0x00> Нет текущих функций.
		FUNCTION_RESET_WAIT		= 0x01,	///< \b <0x01> Ожидание команды сброса.
		FUNCTION_RESET_END		= 0x02,	///< \b <0x02> Сообщение об окончани сброса.
		FUNCTION_RESET			= 0x03,	///< \b <0x03> Ожидание сброса (общее).
		FUNCTION_INTERROG_CONF	= 0x04,	///< \b <0x04> Подтверждение опроса.
		FUNCTION_INTERROG_MONIT	= 0x08,	///< \b <0x08> Данные опроса, либо его окончание.
//		FUNCTION_INTERROG		= 0x0C,	///< \b <0x0C> Наличие опроса (общее).
		FUNCTION_TIME_SYNCH_CONF= 0x10,	///< \b <0x10> Подтверждение синхронизации времени.
//		FUNCTION_TIME_SYNCH_END	= 0x20,	///< \b <0x20> Окончание синхронизации времени.
		FUNCTION_EVENT_CLASS_1	= 0x40,	///< \b <0x40> Наличие данных класса 1 на передачу.
//		FUNCTION_EVENT_CLASS_2	= 0x80,	///< \b <0x80> Наличие данных класса 2 на передачу.
		FUNCTION_IS_ACD			= 0x48	///< \b <0x48> Проверка флагов с наличием данных на передачу.
	} EFunction;

	/// Формат кадра (стартовое слово).
	typedef enum __attribute__ ((__packed__)) {
		FRAME_START_ERROR		  = 0x00,	///< \b <0x00> Ошибочное стартовое слово кадра (нет в МЭК).
		FRAME_START_CHARACTER_FIX = 0x10,	///< \b <0x10> Cтартовое слово кадра с постоянной длиной.
		FRAME_START_CHARACTER_VAR = 0x68	///< \b <0x68> Cтартовое слово кадра с переменной длиной.
	} EFrameStartCharacter;

	/** \brief Идентификатор типа.
	 *
	 *	\note МЭК 870-5-5-96 6 Основные прикладные функции.
	 *	\note IEC 870-5-101 4.2.6 Type identification.
	 *
	 *
	 * 	Байт 1 ИДЕНТИФИКАТОРА БЛОКА ДАННЫХ - ИДЕНТИФИКАТОР ТИПА определяет
	 * 	структуру, тип и формат ОБЪЕКТА(ов) ИНФОРМАЦИИ данного блока ASDU.
	 *
	 *	При определеении ИДЕНТИФИКАТОРА ТИПА используют следующие условные
	 *	обозначения (метки):
	 *	- 1-ый элемент метки:
	 *		- M - передача в направлении контроля;
	 *		- С - передача в направлении управления;
	 *		- P - передача параметров;
	 *		- F - передача файлов.
	 *	- 2-ой элемент метки:
	 *		- две буквы, вид информации.
	 *	- 3-ий элемент метки:
	 *		- T - наличие метки времени;
	 *		- N - отсутствие метки времени.
	 *	- 4-ый элемент метки:
	 *		- обозначение формата данных (A, B, C и т.д.).
	 *
	 * 	ИДЕНТИФИКАТОР ТИПА = UI8[1..8]<1..255>:
	 * 	- <0> - не используется;
	 * 	- <1..127> - диапазон определенный в стандарте;
	 * 	- <128..255> - диапазон не определяется.
	 * 	Значения индентификатора типа от 136 до 255 могут быть определены независимо
	 * 	друг от друга пользователями настоящего стандарта. Однако полная совместимость
	 * 	может быть достигнута только при использовании ASDU со значениями
	 * 	ИДЕНТИФИКАТОР ТИПА от 1 до 127.
	 *
	 * 	ОБЪЕКТЫ ИНФОРМАЦИИ с МЕТКОЙ ВРЕМЕНИ или без нее отличаются различными
	 * 	значениями ИДЕНТИФИКАТОРА ТИПА.
	 */
	typedef enum __attribute__ ((__packed__))  {
		TYPE_ID_M_SP_NA_1 = 1,	///< \b <1> Одноэлементная информация без метки времени.
		TYPE_ID_M_SP_TB_1 = 30,	///< \b <30> Одноэлементная информация с меткой времени СР56Время2а.
		TYPE_ID_M_EI_NA_1 = 70,	///< \b <70> Окончение инициализации.
		TYPE_ID_C_IC_NA_1 = 100,///< \b <100> Команда опроса.
		TYPE_ID_C_CS_NA_1 = 103	///< \b <103> Команда синхронизации часов.
	} ETypeId;


	/**	\enum EFcPrimary
	 * 	\brief Функциональные коды поля управления от первичной станции.
	 *
	 *	Дополнительно разрешены ответы <14> "Услуги канала не работают"
	 *	или <15> "Услуги канала не предусмотрены".
	 *
	 *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
	 *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
	 *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
	 *
	 *	\var RESET_REMOTE_LINK
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <0> - положительное подтверждение;
	 *		- <1> - отрицательное подтверждение.
	 *
	 *	\var RESET_OF_USER_PROCESS
	 *		TODO На данный момент не поддерживается.
	 *		 Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <0> - положительное подтверждение;
	 *		- <1> - отрицательное подтверждение.
	 *
	 *	\var USER_DATA_CONFIRM
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <0> - положительное подтверждение;
	 *		- <1> - отрицательное подтверждение.
	 *
	 *	\var USER_DATA_NO_REPLY
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- Нет ответа.
	 *
	 *	\var REQUEST_FOR_ACCESS_DEMAND
	 *		TODO На данный момент не поддерживается.
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <11> - ОТВЕТ: состояние канала.
	 *
	 *	\var REQUEST_STATUS_OF_LINK
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <11> - ОТВЕТ: состояние канала.
	 *
	 *	\var REQUEST_USER_DATA_CLASS_1
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <8> - ОТВЕТ: данные пользователя;
	 *		- <9> - ОТВЕТ: запрашиваемые данные недоступны.
	 *
	 *	\var REQUEST_USER_DATA_CLASS_2
	 *		Разрешенные функциональные коды и услуги во вторичном направлении:
	 *		- <8> - ОТВЕТ: данные пользователя;
	 *		- <9> - ОТВЕТ: запрашиваемые данные недоступны.
	 */
	typedef enum __attribute__ ((__packed__)) {
		RESET_REMOTE_LINK 			= 0,	///< \b <0> Сброс удаленного канала (FCV = 0).
//		RESET_OF_USER_PROCESS 		= 1,	///< \b <1> Сброс процесса пользователя (FCV = 0).
		USER_DATA_CONFIRM  			= 3,	///< \b <3> Пользовательские данные с ответом (FCV = 1).
		USER_DATA_NO_REPLY	 		= 4,	///< \b <4> Пользовательские данные без ответа (FCV = 0).
//		REQUEST_FOR_ACCESS_DEMAND 	= 8, 	///< \b <8> Запрос доступа по требованию (FCV = 0).
		REQUEST_STATUS_OF_LINK 		= 9,	///< \b <9> Запрос о соcтоянии канала (FCV = 0).
		REQUEST_USER_DATA_CLASS_1 	= 10,	///< \b <10> Запрос данных класса 1 (FCV = 1).
		REQUEST_USER_DATA_CLASS_2 	= 11	///< \b <11> Запрос данных класса 2 (FCV = 1).
	} EFcPrimary;

	/**	\enum EFcSecondary
	 * 	\brief Функциональные коды поля управления от вторичной станции.
	 *
	 *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
	 *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
	 *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
	 */
	typedef enum __attribute__ ((__packed__)) {
		CONFIRM_ACK 			= 0, 	///< \b <0> Положительное подтверждение.
		CONFIRM_NACK 			= 1, 	///< \b <1> Отрицательное подтверждение (сообщение не принято, линия занята).
		RESPOND_USER_DATA		= 8, 	///< \b <8> ОТВЕТ: пользовательские данные.
		RESPOND_NACK 			= 9, 	///< \b <9> ОТВЕТ: запрошенные данные отсутствуют (недоступны).
		RESPOND_STATUS_OF_LINK	= 11, 	///< \b <11> ОТВЕТ: состояние канала связи или запрос доступа.
//		LINK_SERV_NOT_FUNC		= 14,	///< \b <14> Канальный сервис не работает ("Услуги канала не работают").
		LINK_SERV_NOT_IMPL 		= 15 	///< \b <15> Канальный сервис не встроен.
	} EFcSecondary;

	/**	\brief Причина инициализации (Cause of initialisation).
	 *
	 *	\note МЭК 870-5-101-2006 7.2.6.21 Причины инициализации.
	 *	\note IEC 870-5-101 5.2.3.1 End of initialisation.
	 */
	typedef enum __attribute__ ((__packed__)) {
		COI_LOCAL_POWER_ON		= 0,	///< \b <0> Местное включение питания.
		COI_LOCAL_MANUAL_RESET 	= 1,	///< \b <1> Местный ручной возврат в исходное состояние.
		COI_REMOTE_RESET		= 2		///< \b <2> Удаленный возврат в исходное состояние.
	} ECoi;

	/**	\brief Указатель опроса (Qualifier of interrogation).
	 *
	 *	\note МЭК 870-5-101-2006 7.2.6.22 Указатель опроса.
	 *	\note IEC 870-5-101 5.2.4.1 Interrogation command.
	 */
	typedef enum __attribute__ ((__packed__)) {
		QOI_NOT_USED					= 0,	///< \b <0> Не используется.
		QOI_STATION_ITERROGATION_GLB 	= 20	///< \b <20> Опрос станции (общий).
	} EQoi;

	/**	\struct SCauseOfTransmission
	 * 	\brief Причина передачи
	 *
	 *	\var SCauseOfTransmission::t
	 *		BS1[8] <0..1>
	 *		\details В дополнение к ПРИЧИНЕ ПЕРЕДАЧИ бит признака теста определяет
	 *		ASDU, которые были созданы во время тестирования. Этот бит используется,
	 *		например, для проверки тракта передачи аппаратуры без управления
	 *		процессом:
	 *		- <0> - не тест;
	 *		- <1> - тест.
	 *
	 *	\var SCauseOfTransmission::pN
	 *		BS1[7] <0..1>
	 *		\details Показывает , какое (положительное или отрицательное) подтверждение
	 *		активации требуется для передачи прикладной функции. В случае, когда,
	 *		бит P/N не используется, он равен 0.
	 *		- <0> - положительное подтверждение;
	 *		- <1> - отрицательное подтверждение.
	 *
	 *	\var SCauseOfTransmission::cot
	 *		UI6[1..6]<0..63>
	 *		\details #ECot.
	 */
	typedef struct __attribute__ ((__packed__)) {
		ECot cot		: 6;		///< Причина.
		uint8_t pN 	: 1;		///< P/N.
		uint8_t t 	: 1;		///< Тест.
	} SCauseOfTransmission;

	/** \struct SControlFieldPrimary
	 * 	\brief Поле управления при передаче от первичной станции к вторичной.
	 *
	 * 	\var SControlFieldPrimary::res
	 *
	 * 	\var SControlFieldPrimary::prm
	 * 		- <1> - сообщение передается от первичной станции.
	 *
	 * 	\var SControlFieldPrimary::fcb
	 * 		- <0>, <1> - чередующиеся значения бита при последовательных передачах
	 * 		ПОСЫЛКА/ПОДТВЕРЖДЕНИЕ или ЗАПРОС/ОТВЕТ для данной станции. При команде
	 * 		сброса бит всегда равен нулю, а после приема этой команды вторичная
	 * 		станция всегда ожидает следующий кадр от первичной станции к вторичной
	 *		станции с \a #fcv, равным 1, чтобы установить противоположное значение
	 *		\a #fcb, т.е. 1.
	 *
	 * 	\var SControlFieldPrimary::fcv
	 * 		- 0 - изменение бита #fcb неверно и не должно контролироваться при приеме,
	 * 		но значение #fcb должно запоминаться для контроля при следующем приеме с #fcv = 1;
	 * 		- 1 - изменение бита #fcb правильно и должно контролироваться при приеме.
	 *
	 * 	\var SControlFieldPrimary::function
	 * 		\a #EFcPrimary
	 */
	typedef struct __attribute__ ((__packed__)) {
		EFcPrimary function : 4;		///< Функциональный код (function code).
		uint8_t fcv : 1;				///< Законность бита счета кадров (frame count bit valid.).
		uint8_t fcb : 1;				///< Бит счета кадров (frame count bit).
		uint8_t prm : 1;				///< Первичное сообщение (primary message bit).
		uint8_t res : 1;				///< Резерв.
	}  SControlFieldPrimary;

	/**	\struct SControlFieldSecondary
	 * 	\brief Поле управления при передаче от вторичной станции к первичной.
	 *
	 *	\note МЭК 870-5-2-95 5.1.2 Поле управления.
	 *	\note IEC 870-5-101 4.2.3 Control field unbalanced mode.
	 *	\note IEC 870-5-101 4.3 Presentation of frame with fixed lenght, unbalanced mode.
	 *
	 * 	\var SControlFieldSecondary::res
	 *
	 * 	\var SControlFieldSecondary::prm
	 * 		- <0> - сообщение передается от вторичной станции.
	 *
	 * 	\var SControlFieldSecondary::acd
	 * 		- <0> - нет запроса на передачу данных класса 1;
	 * 		- <1> - запрос на передачу данных класса 1.
	 *
	 *	\var SControlFieldSecondary::dfc
	 * 		- <0> - прием сообщений возможен;
	 * 		- <1> - прием сообщений не возможет из-за переполнения буфера.
	 *
	 *	\var SControlFieldSecondary::function
	 * 		\a #EFcSecondary
	 */
	typedef struct __attribute__((__packed__)) {
		EFcSecondary function : 4;			///< Функция.
		uint8_t dfc : 1;					///< Контроль потока данных (data flow control).
		uint8_t acd : 1;					///< Бит требования запроса данных (access demand).
		uint8_t prm : 1;					///< Первичное сообщение (primary message bit).
		uint8_t res : 1;					///< Резерв.
	} SControlFieldSecondary;

	/// Поле управления.
	typedef union {
		uint8_t common;						///< Общее.
		SControlFieldPrimary primary;		///< От первичной ко вторичной станции.
		SControlFieldSecondary secondary;	///< От вторичной к первичной станции.
	} UControlField;

	/** \struct SDataUnitId
	 * 	\brief Идентификатор блока данных.
	 *
	 * 	\var SDataUnitId::typeId
	 * 		UI8[1..8]<1..255>
	 *		\details Определяет структуру, тип и	формат объекта(ов) информации
	 * 		данного блока ASDU. Значение .	Контролирующая станция игнорирует ASDU
	 * 		с не определенным для данной системы значением идентификатора типа.
	 *
	 * 	\var SDataUnitId::variableStructureQualifier
	 * 		- Число = UI7[1..7]<0..127>:
	 * 			- <0> - ASDU не содержит ОБЪЕКТОВ ИНФОРМАЦИИ;
	 * 			- <1>..<127> - число ОБЪЕКТОВ или ЭЛЕМЕНТОВ ИНФОРМАЦИИ.
	 * 		- SQ = BS1[8]<0..1>:
	 * 			- <0> - адресация индивидуальных ОДИНОЧНЫХ ЭЛЕМЕНТОВ или КОМБИНАЦИЙ
	 * 			ЭЛЕМЕНТОВ в наборе ОБЪЕКТОВ ИНФОРМАЦИИ одинакового типа;
	 * 			- <1> - адресация ПОСЛЕДОВАТЕЛЬНОСТИ ОДИНОЧНЫХ ЭЛЕМЕНТОВ ИНФОРМАЦИИ
	 * 			или одинаковых КОМБИНАЦИЙ ЭЛЕМЕНТОВ в единственном объекте ASDU.
	 *
	 * 	\var SDataUnitId::causeOfTramsmission
	 * 		\a #ECot
	 *
	 * 	\var SDataUnitId::commonAddressOfASDU
	 * 		Это адрес станции, который может быть структурирован, чтобы иметь
	 * 		возможность адресации ко всей станции или только к отдельному
	 * 		сектору станции.
	 */
	typedef struct {
		ETypeId typeId;							///< Идентификатор типа.
		uint8_t variableStructureQualifier;		///< Классификатор переменной структуры.
		SCauseOfTransmission causeOfTramsmission;///< Причина передачи.
		uint8_t commonAddressOfASDU;			///< Общий адрес ASDU.
	} SDataUnitId;

	/// Общие поля структуры ASDU для всех команд
	typedef struct {
		SDataUnitId dataUnitId;					///< Идентификатор блока данных.
		uint16_t informationObjectAddress;		///< Адрес объекта информации.
	} SAsduCommon;

	/**	\struct SSiq
	 * 	\brief Одноэлементная информация с описателем качества.
	 *  Single-point information with quality descriptor.
	 *
	 * 	\var SSiq::spi
	 * 		BS[1]<0..1>
	 * 		\details <b> Значение бита ТС </b>:
	 * 		- <0> - выкл;
	 * 		- <1> - вкл.
	 *
	 * 	\var SSiq::res
	 * 		BS3[2..4]<0>
	 *
	 * 	\var SSiq::bl
	 * 		BS1[5]<0..1>
	 *		\details Значение ОБЪЕКТА ИНФОРМАЦИИ блокировано для передачи, оно
	 * 		остается в состоянии, в котором было до блокировки. Блокировка и
	 * 		деблокировака могут инициироваться местным блокирующим устройством
	 * 		или автоматически на основаниии местной причины:
	 * 		- <0> - нет блокировки;
	 * 		- <1> - блокировка.
	 *
	 * 	\var SSiq::sb
	 * 		BS[6]<0..1>
	 * 		\details Значение ОБЪЕКТА ИНФОРМАЦИИ поступает на вход или от
	 * 		оператора (диспетчера) или от автоматического истончника:
	 * 		- <0> - нет замещения;
	 * 		- <1> - замещение.
	 *
	 * 	\var SSiq::nt
	 * 		BS[7]<0..1>
	 * 		\details Значение акутально, если большинство опросов было успешным.
	 * 		Значение неактуально, если оно не обновлялось в течение заданного
	 * 		промежутка времени или было недоступно:
	 * 		- <0> - актуальное значение;
	 * 		- <1> - неактуальное значение.
	 *
	 * 	\var SSiq::iv
	 * 		BS[8]<0..1>
	 * 		\details Действительно, если правильно получено. После того, как
	 * 		функция опроса обноруживает неправильные условия в источнике информации
	 * 		(поврежденные или неработающие устройства опроса), значение величины
	 * 		маркируется как недействительное. При этих условаиях значение ОБЪЕКТА
	 * 		ИНФОРМАЦИИ не определено. Бит "недействительно" используется для
	 * 		указания получателю, что значение величичны может быть неправлильным
	 *		и им нельзя пользоваться:
	 *		- <0> - действительная;
	 *		- <1> - недействительная.
	 */
	typedef struct  __attribute__((__packed__)) {
		uint8_t spi: 1;	///< Одноэлементная информация (single point information).
		uint8_t res: 3;	///< Резерв.
		uint8_t bl : 1;	///< Блокировка/нет блокировки.
		uint8_t sb : 1;	///< Проведено замещение/ нет замещения.
		uint8_t nt : 1;	///< Неактуальное/актуальное значение.
		uint8_t iv : 1;	///< Недействительное/действительное значение.
	} SSiq;

	/**	\struct SCoi
	 * 	\brief Причины инициализации (Cause Of Initialisation).
	 *
	 *	\var SCoi::cause
	 *		UI7[1..7]<0..127>
	 *		\details \a #ECoi
	 *
	 *	\var SCoi::init
	 *		BS1[8]<0..1>
	 *		- <0> - инициализация при неизменных местных параметрах;
	 *		- <1> - инициализация после изменения местных параметров.
	 */
	typedef struct  __attribute__((__packed__)) {
		ECoi cause 	  : 7;	///< Причина.
		uint8_t init  : 1;	///< Инициализация.
	} SCoi;

	/**	\struct SQoi
	 * 	\brief Указатель опроса (Qualifier of interrogation).
	 *
	 *	\var SQoi::qoi
	 *		UI8[1..8]<0..255>
	 *		\details \a #EQoi
	 *
	 */
	typedef struct  __attribute__((__packed__)) {
		EQoi qoi;	///< Указатель опроса.
	} SQoi;

	/**	\brief Одноэлементная информация без метки времени (Single-point information without time tag).
	 *
	 * 	Идентификатор типа = 1.
	 *
	 *	\note МЭК 870-5-101 7.3.1.1 Идентификатор типа 1: M_SP_NA_1.
	 *	\note IEC 870-5-101 5.2.1.1 Single-point information without time tag.
	 *
	 *	Элемент информации - один бит ТС с описателем качества без метки времени.
	 *	Тип блока данных \b <1> может иметь как первую структуру - последовательность
	 *	из \b i одноэлементных объектов, так и втроую - один объект, содержащий
	 *	\b j элементов.
	 *
	 *	Элемент информации - один байт следующей структуры: \a Siq.
	 *
	 *	Последовательность объектов информации (SQ = 0):
	 *	- Идентификатор блока данных:
	 *		- Идентификатор типа;
	 *		- Классификатор переменной структуры;
	 *		- Причина передачи;
	 *		- Общий адрес ASDU.
	 *	- Объект информации 1:
	 *		- Адрес объекта информации;
	 *		- Одноэлементная информация с описателем качества \a Siq;
	 *	...
	 *	- Объект информации 1:
	 *		- Адрес объекта информации;
	 *		- Одноэлементная информация с описателем качества \a Siq;
	 *
	 *	@see asduCommon
	 *	@see DataUnitIdentifier
	 *	@see Siq
	 */
	typedef struct __attribute__((__packed__)) {
		SDataUnitId dataUnitId;	///< Идентификатор блока данных.
		uint16_t informationObjectAddress;		///< Адрес объекта информации.
		SSiq siq;								///< Одноэлементная информация с описателем качества.
	} SMSpNa1;

	/**	\brief Одноэлементная информация с меткой времени СР56Время2а.
	 *
	 * 	Идентификатор типа = 30.
	 *
	 *	\note МЭК 870-5-101 7.3.1.22 Идентификатор типа 30: M_SP_TB_1.
	 *	\note IEC 870-5-101 5.2.1.11 Single-point information with time tag CP56Time2a.
	 *
	 * 	Отличается от типа 1, \a MSpNa1, наличием 7-байтной метки времени. Он
	 * 	может иметь только первую структуру - последовательность из i одноэлементных
	 * 	объектов.
	 *
	 *	Последовательность объектов информации (SQ = 0):
	 *	- Идентификатор блока данных:
	 *		- Идентификатор типа;
	 *		- Классификатор переменной структуры;
	 *		- Причина передачи;
	 *		- Общий адрес ASDU.
	 *	- Объект информации 1:
	 *		- Адрес объекта информации;
	 *		- Одноэлементная информация с описателем качества;
	 *		- Семь байт времени в формате СР56Время2а.
	 *	...
	 *	- Объект информации 1:
	 *		- Адрес объекта информации;
	 *		- Одноэлементная информация с описателем качества;
	 *		- Семь байт времени в формате СР56Время2а.
	 */
	typedef struct __attribute__((__packed__)) {
		SDataUnitId dataUnitId;					///< Идентификатор блока данных.
		uint16_t informationObjectAddress;		///< Адрес объекта информации.
		SSiq siq;								///< Одноэлементная информация с описателем качества.
		SCp56Time2a cp56time2a;					///< Метка времени "Время 2а в двоичном коде" CP56time2a.
	} SMSpTb1;

	/**	\brief Окончание инициализации (End of initialisation).
	 *
	 * 	Индентификатор типа = 70.
	 *
	 *	\note МЭК 870-5-101 7.3.3.1 Идентификатор типа 70: M_EI_NA_1.
	 *	\note IEC 870-5-101 5.2.3.1 End of initialisation.
	 *
	 * 	В блоке данных передается один объект информации - информация о конце
	 * 	инициализации на вторичной станции. Адрес объекта информации равен нулю,
	 * 	т.е. адрес не используется.
	 *
	 * 	Объект информации содержит один информационный байт \a Coi - причина
	 * 	инициализации.
	 *
	 * 	Одиночный объект информации (SQ = 0):
	 * 	- Идентификатор блока данных:
	 *		- Идентификатор типа;
	 *		- Классификатор переменной структуры;
	 *		- Причина передачи;
	 *		- Общий адрес ASDU.
	 *	- Объект информации:
	 *		- Адрес объекта информации;
	 *		- Причина инициализации (COI).
	 */
	typedef struct __attribute__((__packed__)) {
		SDataUnitId dataUnitId;				///< Идентификатор блока данных.
		uint16_t informationObjectAddress;	///< Адрес объекта информации.
		SCoi coi;							///< Причина инициализации.
	} SMEiNa1;

	/**	\brief Команда опроса (Interrogation command).
	 *
	 * 	Идентификатор типа = 100.
	 *
	 *	\note МЭК 870-5-101 7.3.3.1 Идентификатор типа 100: C_IC_NA_1.
	 *	\note IEC 870-5-101 5.2.4.1 Interrogation command.
	 *
	 * 	В блоке данных передается один объект информации - команда группового
	 * 	запроса данных. Адрес объекта информации равен нулю. Объект информации
	 * 	содержит один информационный байт \a Qoi - описатель запроса.
	 *
	 * 	Одиночный объект информации (SQ = 0):
	 * 	- Идентификатор блока данных:
	 *		- Идентификатор типа;
	 *		- Классификатор переменной структуры;
	 *		- Причина передачи;
	 *		- Общий адрес ASDU.
	 *	- Объект информации:
	 *		- Адрес объекта информации;
	 *		- Указатель опроса (QOI).
	 */
	typedef struct __attribute__((__packed__)) {
		SDataUnitId dataUnitId;				///< Идентификатор блока данных.
		uint16_t informationObjectAddress;	///< Адрес объекта информации.
		SQoi qoi;							///< Указатель опроса.
	} SCIcNa1;

	/**	\brief Команда синхронизации часов (Clock synchronisation command).
	 *
	 * 	Идентификатор типа = 103.
	 *
	 *	\note МЭК 870-5-101 7.3.4.4 Идентификатор типа 103: C_CS_NA_1.
	 *	\note IEC 870-5-101 5.2.4.2 Clock synchronisation command.
	 *
	 * 	В блоке данных передается один объект информации - команда синхронизации
	 * 	часов. Адрес объекта информации равен нулю. Данными (не меткой времени)
	 * 	передаваемого объекта информации является значение времени в двоичном
	 * 	формате 7 байт (\a Cp56Time2a).
	 *
	 *	Одиночный объект информации (SQ = 0):
	 * 	- Идентификатор блока данных:
	 *		- Идентификатор типа;
	 *		- Классификатор переменной структуры;
	 *		- Причина передачи;
	 *		- Общий адрес ASDU.
	 *	- Объект информации:
	 *		- Адрес объекта информации;
	 *		- Семь байт времени в формате СР56Время2а.
	 *
	 *	При получении нового времени, оно помещается в буфер \a #stTime. Затем,
	 *	при вызове функции \a getTime() в даный буфер будет записано время вызова
	 *	функции. При следующем запросе данных класса 1 (2), в первичную станцию
	 *	будет передан кадр об окончании синхронизации с временем вторичной
	 *	станции во время синхронизации.
	 */
	typedef struct __attribute__((__packed__)) {
		SDataUnitId dataUnitId;	///< Идентификатор блока данных.
		uint16_t informationObjectAddress;		///< Адрес объекта информации.
		SCp56Time2a cp56Time2a;					///< Метка времени "Время 2а в двоичном коде" CP56time2a.
	} SCCsNa1;

	/**	\brief Обобщенная структура ASDU.
	 *
	 */
	typedef union __attribute__((__packed__)) {
		SAsduCommon common;		///< Данные, общие для всех команд.
		SMSpNa1 mSpNa1;			///< Одноэлементная информация без метки времени.
		SMSpTb1 mSpTb1;			///< Одноэлементная информация с меткой времени СР56Время2а.
		SMEiNa1 mEiNa1;			///< Окончение инициализации.
		SCIcNa1 cIcNa1;			///< Команда опроса
		SCCsNa1 cCsNa1;			///< Команда синхронизации часов.
	} UAsdu;

	/** \struct SFrameFixLength
	 * 	\brief Формат кадра с постоянной длиной.
	 *
	 *	Пользовательских данных нет.
	 *
	 * 	\var SFrameFixLength::startCharacter
	 * 		Должно быть равно \a FRAME_FIX_LENGHT.
	 *
	 *	\var SFrameFixLength::controlField
	 *		Cодержит информацию о направлении сообщения, типе сервиса и обеспечивает
	 *		защиту от потерь и дублирования сообщений. При передаче от первичной
	 *		станции к вторичной поле имеет вид \a CotrolFieldPrimary, при передаче
	 *		от вторичной к первичной - \a ControlFieldSecondary.
	 *
	 *	\var SFrameFixLength::linkAddress
	 *		Адрес передается от первичной станции к приемной и определяет адрес
	 *		места назначения информации. Если равен \a #s_u8AddressGlb, то это общий
	 *		кадр и ответа на него не требуется. Диапазон значений от \a #s_u8AddressMin
	 *		до \a #s_u8AddressMax.
	 *
	 *	\var SFrameFixLength::checkSum
	 *		В данном случае это поле управления + поле адреса.
	 *
	 *	\var SFrameFixLength::stopCharacter
	 *		Должно быть равно \a #s_u8FrameStopCharacter.
	 *
	 *	@see CotrolFieldPrimary
	 *	@see ControlFieldSecondary
	 *	@see ADDRESS_MIN
	 *	@see ADDRESS_MAX
	 *	@see ADDRESS_GLB
	 * 	@see FRAME_FIX_LENGHT
	 * 	@see FRAME_STOP_CHARCTER
	 */
	typedef struct __attribute__((__packed__)) {
		uint8_t 		startCharacter;	///< Байт начала сообщения.
		UControlField  	controlField;	///< Поле управления.
		uint8_t 		linkAddress;	///< Поле адреса (link).
		uint8_t 		checkSum;		///< Контрольная сумма пользовательских данных.
		uint8_t 		stopCharacter;	///< Слово окончания сообщения.
	} SFrameFixLength;

	/**	\struct SFrameVarLength
	 * 	\brief Формат кадра с переменной длиной.
	 *
	 * 	\var SFrameVarLength::startCharacter
	 * 		Должно быть равно \a #EFrameStartCharacter.
	 *
	 *	\var SFrameVarLength::length1
	 *		По МЭК от 0 до 255. В данном случае не более размера буфера
	 *		\a #m_u8Size минус 6 байт.
	 *
	 *	\var SFrameVarLength::length2
	 *
	 *	\var SFrameVarLength::startCharacter2
	 *		Должно быть равно \a #EFrameStartCharacter.
	 *
	 *	\var SFrameVarLength::controlField
	 *		Содержит информацию о направлении сообщения, типе сервиса и обеспечивает защиту от потерь и дублирования
	 *		сообщений. При передаче от первичной станции к вторичной поле имеет вид
	 *		\a ControlFieldPrimary, при передаче от вторичной к первичной
	 *		\a ControlFieldSecondary.
	 *
	 *	\var SFrameVarLength::linkAddress
	 *		Адрес передается от первичной станции к приемной и
	 *		определяет адрес места назначения информации. Если равен \a #s_u8AddressGlb,
	 *		то это общий кадр и ответа на него не требуется. Диапазон значений от
	 *		\a #s_u8AddressMin до \a #s_u8AddressMax.
	 *
	 *	\var SFrameVarLength::asdu
	 *		\a Asdu.
	 *
	 *	\var SFrameVarLength::checkSum
	 *		Сумма по модулю 256. В данном случае это поле управления + поле адреса
	 *		 + пользовательские данные \a #asdu.
	 *
	 *	\var SFrameVarLength::stopCharacter
	 *		Должено быть равено \a #s_u8FrameStopCharacter.
	 */
	typedef struct __attribute__((__packed__)) {
		uint8_t startCharacter;		///< Cлово начала сообщения.
		uint8_t length1;			///< Длина пользовательских данных.
		uint8_t length2;			///< лина пользовательских данных (повтор)
		uint8_t startCharacter2;	///< Слово начала сообщения.
		UControlField  controlField;	///< Поле управления.
		uint8_t linkAddress;		///< Поле адреса (link).
		UAsdu asdu;					///< Блок данных прикладного уровня (пользовательские данные).
		uint8_t checkSum;			///< Контрольная сумма пользовательских данных.
		uint8_t stopCharacter;		///< Слово окнончания сообщения.
	} SFrameVarLength;

public:
	/** Состояния работы протокола.
	 *
	 * 	\attention
	 * 	#STATE_OFF - всегда должен стоять в начале перечисления.
	 *
	 * 	\attention
	 * 	#STATE_ERROR - всегда должен стоять в конце перечисления.
	 *
	 */
	typedef enum __attribute__ ((__packed__)) {
		STATE_OFF 			= 0, ///< \b <0> Протокол выключен.
		// ^^^ - всегда вначале
		STATE_READ			= 1, ///< \b <1> Идет чтение посылки.
		STATE_READ_ERROR	= 2, ///< \b <2> Ошибка в принятом пакете.
		STATE_READ_OK		= 3, ///< \b <3> Посылка принята.
		STATE_WRITE_WAIT	= 4, ///< \b <4> Ожидание нужных данных.
		STATE_WRITE_READY	= 5, ///< \b <5> Посылка готова к отправке
		STATE_WRITE			= 6, ///< \b <6> Идет отправка посылки.
		// vvv - всегда в конце
		STATE_ERROR			= 7  ///< \b <7> Ошибка в работе протокола.
	} EState;

	/// Ошибки проверки принятого кадра.
	typedef enum __attribute__ ((__packed__)) {
		ERROR_NO 			= 0,	///< Ошибок нет.
		ERROR_SIZE_FRAME	= 1,	///< Ошибка размера принятого кадра.
		ERROR_START2_CHAR	= 2,	///< Ошибка второго старт байта.
		ERROR_LENGHT1		= 3,	///< Ошибка первого байта кол-ва данных.
		ERROR_LENGHT2		= 4,	///< Ошибка второго байта кол-ва данных.
		ERROR_STOP_CHAR		= 5,	///< Ошибка стопового байта.
		ERROR_CRC			= 6,	///< Ошибка контрольной суммы.
		ERROR_LINK_ADDRESS	= 7,	///< Ошибка адреса устройства.
		ERROR_PRM_BITE		= 8,	///< Ошибка бита первичного сообщения.
		ERROR_COMMON		= 9		///< Ошибка общая.
	} EError;

	///	\brief Элемент информации.
	typedef struct {
		bool send;			///< True - данные готовы для передачи.
		bool val;			///< Значение.
		uint16_t adr;		///< Адрес.
		SCp56Time2a time;	///< Время.
	} SEI;

	/// Время полученное от первичной станции.
	SCp56Time2a stTime;

	/**	Контструктор.
	 *
	 *	Изначально протокол ожидает сброса, т.е. текущая функция
	 *	\a #FUNCTION_RESET_WAIT.
	 *
	 * 	@param[in] pBuf Буфер данных.
	 * 	@param[in] u8Size Размер буфера данных.
	 */
	CIec101(uint8_t *pBuf, uint8_t u8Size);

	/**	Возвращает адрес устройтсва в протоколе по-умолчанию, т.е. ошибка.
	 *
	 * 	@return Адрес устройства - ошибка.
	 */
	uint8_t getAddressError() const {
		return s_u8AddressErr;
	}

	/**	Возвращает минимальный адрес устройства, доступный в протоколе.
	 *
	 * 	@return Адрес устройства - минимальный.
	 */
	uint8_t getAddressMin() const {
		return s_u8AddressMin;
	}

	/**	Возвращает максимальный адрес устройства, досупный в протоколе.
	 *
	 * 	@return Адрес устройства - максимальный.
	 */
	uint8_t getAddressMax() const {
		return s_u8AddressMax;
	}

	/**	Возвращает глобальный адрес.
	 *
	 * 	@return Глобальный адрес.
	 */
	uint8_t getAddressGlb() const {
		return s_u8AddressGlb;
	}

	/**	Запуск работы данного протокола.
	 *
	 */
	void setEnable() {
		setState(STATE_READ);
	}

	/**	Остановка работы данного протокола.
	 *
	 *	Текущая функция утсанавливается в ожидание сброса \a #FUNCTION_RESET_WAIT.
	 */
	void setDisable() {
		m_u8Func = FUNCTION_RESET_WAIT;
		setState(STATE_OFF);
	}

	/** Проверка текущего состояния работы данного протокола
	 *
	 *	@retval True - если протокол включен.
	 *	@retval False - если протокол отключен.
	 */
	bool isEnable() const {
		return (m_eState != STATE_OFF);
	}

	/**	Смена состояния на ожидание новой посылки.
	 *
	 */
	void setReadState() {
		setState(STATE_READ);
	}

	/**	Проверка наличия принятой посылки.
	 *
	 * 	@retval True - при наличии принятой посылки.
	 * 	@retval False - при отсутствии принятой посылки
	 */
	bool isReadData() const {
		return (m_eState == STATE_READ_OK);
	}

	/**	Смена состояния работы протокола.
	 *
	 *	Вынесена в public только для возможности тестирования работы класса!!!
	 *
	 *	В случае ошибочного значения, протокол останется в текущем состоянии.
	 *
	 *	При смене состояния на "Чтение", происходит обнуление счетчика принятых
	 *	байт данных и времени прошедшего с момента приема последнего байта.
	 *
	 * 	@param[in] state Новое состояние работы протокола.
	 */
	void setState(CIec101::EState state);

	/**	Проверка совпадения нужного состояния с текущим.
	 *
	 *	@param[in] state Проверяемое состояние.
	 * 	@retval True - если протокол в нужном состоянии.
	 * 	@retval False - если состояние протокола отличается от нужного.
	 */
	bool checkState(CIec101::EState state) const {
		return (m_eState == state);
	}

	/**	Возвращает текущее состояние протокола.
	 *
	 *	Вынесена в public только для возможности тестирования работы класса!!!
	 *
	 *	@return Текущее состояние протокола.
	 */
	CIec101::EState getState() const {
		return m_eState;
	}

	/**	Принятый байт данных.
	 *
	 *	При переполнении буфера байт будет просто проигнорирована.
	 *
	 *	Производится сброс счетчика времени, прошедшего с момента прихода
	 *	последнего байта.
	 *
	 *	@param[in] u8Byte Байт данных.
	 *	@return Возвращает кол-во принятых данных в буфере.
	 */
	uint8_t push(uint8_t u8Byte);

	/** Возвращает кол-во байт в принятой посылке или готовых к отправке.
	 *
	 *	Используется для тестов.
	 *
	 * 	@return Кол-во байт данных.
	 */
	uint8_t getNumOfBytes() const {
		return m_u8Cnt;
	}

	/**	Настройка счетчика времени.
	 *
	 * 	Исходя из полученной скорости работы протокола, наличия контроля
	 * 	четности и кол-ва стоп-битов, а так же частоты вызова функции \a tick(),
	 * 	рассчитывается шаг счета. При этом принимается кол-во "бит данных"
	 * 	всегда 8, а кол-во бит "контроль четности" + "стоп-биты" равно 2.
	 *
	 * 	Например:
	 * 	для скорости  19200 и частоте вызова функции 1 раз в 50мкс, получим:
	 *
	 *	step = (11 * 1.5 * 10^6) / (\a u8Period * \a u16Baudrate) = 17
	 * 	,где	11 - кол-во бит для передачи одного байта данных;
	 * 			1.5 - пауза до обнаружения окончания кадра, в байтах данных;
	 * 			10^6 - перевод в мкс, т.к u8Period в мкс.
	 *
	 * 	Рассчитывается время передачи кадра синхронизации времени от сервера
	 * 	до ПИ в мс.
	 *
	 *	Например:
	 *	для скорости 19200 получим:
	 *	delay = (11 * 21 * 10^3) / (\a u16Baudrate) = 12 мс
	 *	,где	11 - кол-во бит для передачи одного байта данных;
	 *			21 - кол-во байт данных в кадре синхронизации времени;
	 *			10^3 - перевод в мс.
	 *
	 *	Запоминается частота вызова функции \a tick().
	 *
	 *	@param[in] u16Baudrate Скорость работы последовательного порта, бит/с.
	 *	@param[in] u8Period Частота вызова функции \a tick(), мкс.
	 *	@return Рассчитанный шаг счетчика.
	 */
	uint16_t setTick(uint16_t u16Baudrate, uint8_t u8Period);

	/**	Счет времени прошедшего с момента прихода последнего байта.
	 *
	 *	Счетчик считает всегда.
	 *
	 *	Как только счетчик времени достигнет (превысит) \a # m_u16TickTime, т.е.
	 *	будет обнаружен необходимый интервал спокойного состояния в 1.5 байта:
	 *	- в состоянии \a #STATE_READ необходимо не менее 5 принятых байт  для
	 *	перехода в состояние принятой посылки \a #STATE_READ_OK, иначе
	 *	снова будет установлено \a #STATE_READ.
	 *	В состоянии \a #STATE_READ_ERROR идет ожидание требуемого интервала
	 *	спокойного состояния (2 * \a #m_u16TickTime или 3 байта), а затем переход
	 *	в \a #STATE_READ (т.е. ожидание новой посылки).
	 *
	 * 	\attention Вызывается с заданной в \a setTick() частотой, например, из
	 * 	прерывания.
	 */
	void tick();

	/**	Возвращает задержку времени.
	 *
	 * 	Задержка состоит из трех основных составляющих:
	 * 	- время передачи от сервера до БСП-ПИ, зависит от скорости порта;
	 * 	- время прошедшее с момента приема кадра от сервера, до момента отправки
	 * 	в БСП;
	 * 	- время передачи от БСП-ПИ до БСП, фиксировано (зависит от настроек порта).
	 *
	 */
	uint16_t getDelay() const;

	/**	Установка адреса устройства в сети.
	 *
	 *	В случае ошибочного значения, смены адреса не происходит.
	 *
	 * 	@param[in] u8Adr Адрес устройства.
	 * 	@retval True - в случае смены адреса устройства.
	 * 	@retval False - в случае ошибочного адреса.
	 */
	bool setAddressLan(uint8_t u8Adr);

	/**	Возвращает адрес устройства в сети.
	 *
	 * 	@return Адрес устройства.
	 */
	uint8_t getAddressLan() const {
		return m_u8Address;
	}

	/**	Отправка сообщения.
	 *
	 *	В случае, если состояние отличается от состояния готовности к передаче
	 *	\a #STATE_WRITE_READY, количество байт данных на передачу будет равно 0.
	 *	При наличии данных для передачи состояние изменится на \a #STATE_WRITE.
	 *
	 *	Флаг наличия сообщения
	 *
	 * 	@return Кол-во байт данных для передачи.
	 */
	uint8_t sendData();

	/**	Обработка принятых данных.
	 *
	 *	В зависимости от обнаруженных ошибок в принятом пакете состояние изменится
	 *	на ошибочное \a #STATE_READ_ERROR. При котором следует дождаться определенного
	 *	интервала спокойного состояния на линии.
	 *
	 *	Формируется ответ. При наличии готового ответа состояние изменяется на
	 *	\a #STATE_WRITE_READY.
	 */
	void readData();

	/**	Возвращает текущее состояние флага сброса протокола.
	 *
	 *	Функция введена для удобства тестирования.
	 *
	 * 	@retval True - протокол сброшен и находится в рабочем состоянии.
	 * 	@retval False - протокол ожидает сброса.
	 */
	bool isReset() const{
		return !(m_u8Func & FUNCTION_RESET_WAIT);
	}

#ifdef MY_TESTS
	/**	Установка флага наличия сообщений класса 1 (2).
	 *
	 * 	Используется только для тестирования.
	 */
	uint8_t class2;
	void sendClass2() {
		class2 = 4;
	}

	uint8_t class1;
	void sendClass1() {
		class1 = 2;
	}

#endif


private:
	const uint8_t m_u8Size;		///< Размер буфера данных
	uint8_t * const m_pBuf;		///< Буфер принятых/передаваемых данных

	EState m_eState;			///< Текущее состояние работы протокола.
	uint8_t m_u8Address;		///< Адрес устройства в сети.
	volatile uint8_t m_u8Cnt;	///< Кол-во принятых байт.
	volatile uint16_t m_u8Tick;	///< Время прошедшее с момента приема последнего байта.
	uint8_t m_u8TickPeriod;		///< Частота вызова функции \a tick() в мкс.
	uint16_t m_u16TickTime;		///< Шаг счета паузы.
	uint16_t m_u16DelayPc;		///< Задержка передачи кадра от сервера.


	uint8_t m_u8Func;			///< Флаги текущих функций протокола (\a #EFunction).
	uint8_t m_u8Fcb;			///< Ожидаемый бит счета кадров. <0> или <1>.

	bool m_bInterrog;			///< Флаг необходимости отправки сообщений опроса.
	SCp56Time2a m_stCp56time2a;	///< Хранилище времени.
	SFrameFixLength m_stFrameFix;///< Кадр фиксированной длины.
	SFrameVarLength m_stFrameVar;///< Кадр переменной длины.
	EFrameStartCharacter m_eFrameSend;	///< Кадр подготовленный для передачи.

	SEI ei1;	/// Элемент информации класса 1 для отправки.
	SEI ei2;	/// Элемент информации класса 2 для отправки.

	/**	Проверка необходимости передать новое сообщении класса 1.
	 *
	 *	Флаг наличия данных для передачи устанавливается, если:
	 *	- Установлена функция текущего состояния - опрос (iterrogation);
	 *	- Имеются данные класса 1 на передачу.
	 *
	 *	@retval 0 Нет данных на передачу.
	 *	@retval 1 Есть данные на передачу.
	 */
	uint8_t isAcd();

	/**	Проверка бита счета кадров.
	 *
	 *	@param[in] rCf Поле управления при передаче от первичной станции к вторичной.
	 * 	@retval False Бит не соответствует ожиданиям. Ошибка.
	 * 	@retval True Бит соответствует ожиданиям. Все норм.
	 */
	bool checkFcb(SControlFieldPrimary &rCf) const {
		return (!rCf.fcv) || (rCf.fcb == m_u8Fcb);
	}

	/**	Установка активной функции протокола.
	 *
	 * 	@param[in] func Функция протокола.
	 */
	void setFunc(EFunction func) {
		m_u8Func |= func;
	}

	/**	Сброс активной функции протокола.
	 *
	 * 	@param[in] func Функция протокола.
	 */
	void clrFunc(EFunction func) {
		m_u8Func &= ~func;
	}

	/**	Проверка активности функции протокола.
	 *
	 * 	@param[in] func Проверяемая функция протокола.
	 * 	@retval True Функция протокола активна.
	 * 	@retval False Фунция протокола не активна.
	 */
	bool isFunc(EFunction func) const {
		return (m_u8Func & func);
	}

	/** Подсчет контрольной суммы для кадра с фиксированной длиной.
	 *
	 *	@param[in] rFrame Кадр с фиксированной длиной.
	 * 	@return Контрольную сумму в кадре.
	 */
	uint8_t getCrcFixFrame(SFrameFixLength &rFrame) const;

	/**	Подсчет контрольной суммы для кадра с переменной длиной.
	 *
	 * 	Для рассчета КС используется первое поле длины пользовательских данных.
	 *
	 *	@param[in] rFrame Кадр с переменной длиной.
	 * 	@return Контрольную сумму в кадре.
	 */
	uint8_t getCrcVarFrame(SFrameVarLength &rFrame) const;

	/**	Проверка кадра с фиксированной длиной.
	 *
	 *	Возвращает 0, если ошибок нет.
	 *
	 *	@param[in] rFrame Кадр с фиксированной длиной.
	 * 	@return Код ошибки, в случае ее наличия (\a #EError)
	 */
	CIec101::EError checkFrameFixLenght(SFrameFixLength &rFrame) const;

	/**	Проверка принятого кадра.
	 *
	 * 	В зависимости от обнаруженных ошибок в принятом пакете состояние изменится
	 *	на ошибочное \a #STATE_READ_ERROR. При котором следует дождаться определенного
	 *	интервала спокойного состояния на линии.
	 *
	 * 	@return Код ошибки, в случае ее наличия (\a #EError)
	 */
	CIec101::EError checkFrame();

	/** Проверка кадра с переменной длиной.
	 *
	 *	Возвращает 0, если ошибок нет.
	 *
	 *	@param[in] rFrame Кадр с переменной длиной.
	 * 	@return Код ошибки, в случае ее наличия (\a #EError)
	 */
	CIec101::EError checkFrameVarLenght(SFrameVarLength &rFrame) const;

	/**	Обработка кадра с фиксированной длиной.
	 *
	 *	Если ответа не требуется, будет осуществлен переход в ожидание следующего
	 *	кадра.
	 *
	 *	\attention Изначально ожидаются кадры сброса от первичной станции, до их
	 *	прихода все отсальные кадры игнорируются.
	 *
	 *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
	 *	unbalanced transmission systems.
	 *
	 *	@param[in] rFrame Кадр с фиксированной длиной.
	 */
	void readFrameFixLenght(SFrameFixLength &rFrame);

	/**	Обработка кадра с переменной длиной.
	 *
	 *	\attention Изначально ожидаются кадры сброса от первичной станции, до их
	 *	прихода все отсальные кадры игнорируются.
	 *
	 *	\note IEC 870-5-1 6.1.1.2 Local initialisation of the controlled station in
	 *	unbalanced transmission systems.
	 *
	 *	@param[in] rFrame Кадр с переменной длиной.
	 */
	void readFrameVarLenght(SFrameVarLength &rFrame);

	/**	Отправка подготовленного кадра.
	 *
	 * 	Состояние изменяется на \a #STATE_WRITE_READY.
	 */;
	void sendFrame();

	/**	Отправка кадра с фиксированной длиной.
	 *
	 *	Отправлен будет последний подготовленный кадр, переменной или постоянной
	 *	длины.
	 *
	 *	Состояние изменяется на \a #STATE_WRITE_READY.
	 */
	void sendFrameFixLenght();

	/**	Отправка кадра с переменной длиной.
	 *
	 * 	Сформированный кадр (\a prepareFrameVarLenght())  уже лежит в \a frameVar_.
	 *
	 *	В буфер передачи сначала копируется заголовок (4 байта) и пользовательские
	 *	данные (зависит от идентификатора типа).
	 *
	 *	Проверяется наличие данных класса 1 на передачу, и если они есть
	 *	утсанавливается бит требования запроса данных.
	 *
	 *	Затем подсчитывается КС и добавляется стоп-байт.
	 *
	 * 	Состояние изменяется на \a #STATE_WRITE_READY.
	 */
	void sendFrameVarLenght();

	/**	Подготовка кадра с постоянной длиной к отправке.
	 *
	 * 	Формируется кадр фиксированной длины с полем управления содержащим
	 *	функциональный код \a function и бит требования запроса данных  \a acd.
	 *
	 *	Состояние изменяется на \a #STATE_WRITE_READY.
	 *
	 *	@see ControlFieldSecondary
	 *	@param[in] eFunction Функциональный код.
	 */
	void prepareFrameFixLenght(EFcSecondary eFunction);

	/**	Подготовка кадра с переменной длиной к отправке.
	 *
	 *	В блоке данных прикладного уровня (ASDU) заполняются только поля
	 *	идентификатора блока данных. Остальное должно быть подготовлено заранее.
	 *
	 *	После подготовки кадра устанавливается флаг наличия подготовленного
	 *	сообщения класса 1 \a #m_bAcd.
	 *
	 *	В классификатор переменной структуры всегда пишется \a #s_u8VariableStructureQualifier,
	 *	что означает что число передаваемых ОБЪЕКТОВ ИНФОРМАЦИИ всегда равно 1.
	 *
	 *	@param[in] eId Идентификатор типа.
	 *	@param[in] eCot Причина передачи.
	 *	@param[in] u8SizeAsdu Длина пользовательских данных.
	 */
	void prepareFrameVarLenght(ETypeId eId, ECot eCot, uint8_t u8SizeAsdu);

	/**	Подготовка кадра одноэелементной информации без метки времени.
	 *
	 *	Все элементы \a SSiq, за исключением значения элемента, обнуляются.
	 *
	 *	@param[in] u16Address Адрес объекта информации.
	 *	@param[in] eCause Причина передачи \a #ECot.
	 *	@param[in] bVal Передаваемое значение.
	 */
	void prepareFrameMSpNa1(uint16_t u16Address, ECot eCause, bool bVal);

	/**	Подготовка кадра окончания инициализации.
	 *
	 *	@param[in] eCause Причина инициализации \a #ECoi.
	 */
	void prepareFrameMEiNa1(ECoi eCause);

	/**	Подготовка кадра опроса.
	 *
	 *	Указатель опроса всегда передается \a #QOI_NOT_USED.
	 *
	 *	Адрес объекта информации равен нулю.
	 *
	 *	@param[in] eCause Причина передачи \a #ECot.
	 */
	void prepareFrameCIcNa1(ECot eCause);

	/**	Подготовка кадра синхронизации времени (окончание).
	 *
	 *	Производится копирование времени аппарата на момент установки нового.
	 *
	 * 	@param[in] eCause Причина передачи \a #ECot.
	 */
	void prepareFrameCCsNa1(ECot eCause);

	/**	Обработка кадра фиксированной длины с функцией запроса данных класса 1 и 2.
	 *
	 *	Проверяется наличие текущих функций протокола (\a #m_u8Func) по порядку:
	 *	- \a #FUNCTION_RESET_END - отправяется кадр окончания сброса, при условии
	 *	что бит счета кадров равен 1;
	 *	- Если принятый бит счета кадров не равен ожидаемому повторно передается
	 *	предыдущий кадр;
	 *	- \a #FUNCTION_TIME_SYNCH_CONF - проверяется наличие времения для отправки
	 *	кадра окончания синхронизации времени, с мектой локального времени в
	 *	момент синхронизации;
	 *	- \a #FUNCTION_INTERROG_CONF - отправляется кадр подтверждения начала
	 *	опроса;
	 *	- \a #FUNCTION_INTERROG_MONIT - отправляется кадр с данными опроса, либо
	 *	кадр окончания опроса.
	 *	- проверяется наличие данных класса 1 и 2 на передачу, если они есть -
	 *	идет их отправка, иначе передается кадр NACK.
	 *
	 * 	@param[in] rFrame Кадр с фиксированной длиной.
	 */
	void procFrameFixLenghtUserData(SFrameFixLength &rFrame);

	/**	Обработка принятого кадра с переменной длиной.
	 *
	 *	@param[in] asdu Принятый блок данных.
	 *	@retval True Кадр обработан.
	 * 	@retval False Кадр не обработан.
	 */
	bool procFrameVarLenght(UAsdu asdu);

	/**	Проверка наличия данных класса 1 на передачу.
	 *
	 *	@param adr[out] Адрес.
	 *	@param val[out] Значение.
	 *	@param time[out] Дата и время.
	 * 	@retval False Нет данных на передачу.
	 * 	@retval True Есть данные на передачу.
	 */
	virtual bool checkEventClass1(uint16_t &adr, bool &val, SCp56Time2a &time);

	/**	Проверка наличия данных класса 2 на передачу.
	 *
	 *	@param adr[out] Адрес.
	 *	@param val[out] Значение.
	 *	@param time[out] Дата и время.
	 * 	@retval False Нет данных на передачу.
	 * 	@retval True Есть данные на передачу.
	 */
	virtual bool checkEventClass2(uint16_t &adr, bool &val, SCp56Time2a &time);

	/**	Отправка события класса 1.
	 *
	 *	@retval True Подготовлены данные для передачи.
	 *	@retval False Данных нет.
	 */
	bool procEventClass1();

	/**	Отправка события класса 2.
	 *
	 * 	@retval True Подготовлены данные для передачи.
	 *	@retval False Данных нет.
	 *
	 */
	bool procEventClass2();

	/**	Обработка ответа на команду опроса.
	 *
	 *	При корректном адресе подготавливается кадр C_IC_NA_1 и возвращается \a
	 *	True, иначе False.
	 *
	 *	В данной функции возвращаются:
	 *	- адреса 201, 202 = false;
	 *	- адреса 203, 204 = true;
	 *
	 *	@param adr[out] Адрес.
	 *	@param val[out] Значение.
	 *	@retval True Подготовлены данные для передачи.
	 *	@retval False Данных нет.
	 */
	virtual bool procInterrog(uint16_t &adr, bool &val);

	/**	Установка времени.
	 *
	 *	Вызывается автоматически, при получении кадра синхронизации времени.
	 *
	 *	При вызове формируется метка времени:
	 *	4.05.06 03:02:01.000
	 *
	 * 	@retval True Время установлено.
	 * 	@retval False Время не установлено.
	 */
	virtual bool procSetTime() {
		return true;
	}

	/**	Наличие полученного времени в момент синхронизации.
	 *
	 * 	Вызывается автоматически при принятии пакетов фиксированой длины, просле
	 * 	кадра синхронизации времени.
	 *
	 *	При вызове формируется метка времени:
	 *	4.05.06 03:02:01.000
	 *
	 * 	@retval bool True Время в момент синхронизации получено.
	 * 	@retval bool False Времени для ответа нет.
	 */
	virtual bool procSetTimeEnd();

	/**	Обработка принятого кадра синхронизации часов.
	 *
	 *	Кадр синхронизации часов будет обработан, если:
	 *	- принятая причина передачи "Активация" (\a #COT_ACT).
	 *
	 *	В ответ будет сформирован кадр фиксированной длины \a #CONFIRM_ACK. А по
	 *	завершению синхронизации кадр переменной длины \a #TYPE_ID_C_CS_NA_1 c
	 *	текущим временем до синхронизации и причиной "Завершенеи активации" (\a
	 *	#COT_ACTCON).
	 *
	 *	К текущим функциям добавится \a #FUNCTION_TIME_SYNCH_CONF.
	 *
	 *	Производится вызов функции \a procSetTime(), в кторой по умолчанию
	 *	происходит установка времени, т.е. вызов \a getTime().
	 *
	 * 	@param[in] stCCsNa1 Кадр синхронизации часов.
	 * 	@retval True Кадр обработан.
	 * 	@retval False Кадр не обработан.
	 */
	bool procFrameCCsNa1(SCCsNa1 stCCsNa1);

	/**	Обработка принятого кадра опроса.
	 *
	 *	Кадр опроса будет обработан, если:
	 *	- принятая причина передачи "Активация" (\a #COT_ACT).
	 *
	 *	В ответ будет сформирован кадр фиксированной длины \a #CONFIRM_ACK. А по
	 *	завершению синхронизации кадр переменной длины \a #TYPE_ID_C_IC_NA_1 c
	 *	причиной передачи "Завершение активации" (\a #COT_ACTTERM).
	 *
	 *	К текущим функциям добавится \a #FUNCTION_INTERROG_CONF.
	 *
	 *	Счетчик опроса будет сброшен.
	 *
	 *	@param[in] stCIcNa1 Кадр опроса.
	 * 	@retval True Кадр обработан.
	 * 	@retval False Кадр не обработан.
	 */
	bool procFrameCIcNa1(SCIcNa1 stCIcNa1);

	/**	Копирование метки времени Cp56Time2a.
	 *
	 * 	Копирование ведется из \a rSource в \a rDist.
	 *
	 *	@param[out] rDist Куда копируется метка времени.
	 *	@param[in] rSource Откуда копируется метка времени.
	 */
	void copyCp56time2a(SCp56Time2a &rDist, const SCp56Time2a &rSource);

protected:

	/**	Подготовка кадра одноэелементной информации с меткой времени.
	 *
	 * 	Все эелементы \a SSiq, за исключением значения элемента, обнуляются.
	 *
	 * 	@param[in] u16Address Адрес объекта информации.
	 *	@param[in] eCause Причина передачи \a #ECot.
	 *	@param[in] bVal Передаваемое значение.
	 *	@param[in] rTime Массив с текущим временем.
	 */
	void prepareFrameMSpTb1(uint16_t u16Address, ECot eCause,
			bool bVal, SCp56Time2a &rTime);

	/**	Заполнение метки времени Cp56Time2a.
	 *
	 * 	@param[out] rTime Метка времени для заполнения
	 * 	@param[in] years Год.
	 * 	@param[in] months Месяц.
	 * 	@param[in] day День месяца.
	 * 	@param[in] hours Часы.
	 * 	@param[in] min Минуты.
	 * 	@param[in] sec Секунды.
	 * 	@param[in] msec Миллисекунды.
	 */
	void writeCp56Time2a(SCp56Time2a &rTime, uint8_t years, uint8_t months,
			uint8_t day, uint8_t hours, uint8_t min, uint8_t sec, uint16_t msec);
};

#endif /* CIEC101_H_ */
