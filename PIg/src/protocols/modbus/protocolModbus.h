/*
 * bsp.h
 *
 *  Created on: 23.05.2014
 *      Author: Shcheblykin
 */

#ifndef PROTOCOL_MODBUS_H_
#define PROTOCOL_MODBUS_H_

#include <stdint.h>

/**	\brief Класс работы с протоколом MODBUS.
 *
 *	Для работы протокола необходимо:
 *	- переопределить виртуальные обработчики под свой словарь объектов;
 *	- вызывать функцию push() при принятии очередного байта данных, например
 *	в прерывании приема;
 *	- по покончанию передачи ответа вызвать функцию setReadState();
 *	- вызывать функцию tick() с заданным в функции setTick() периодом, например
 *	из прерывания таймера;
 *
 *	Для начала работы необходимо выполнить следующие шаги:
 *	- установить адрес устойства в сети MODBUS, например setAddress(17);
 *	- установить шаг счета паузы между принятыми данными, например для скорости
 *	19200 бит/с и периодом вызова функции tick() 50мкс setTick(19200, 50);
 *	- запустить протокол setEnable().
 *
 *	При обнаружении принятой посылки isReadData(), надо вызвать функцию
 *	readData().
 *
 *	Вызвать функцию передачи ответа sendData() и если она вернет не нулевое
 *	количество подготовленных для передачи байт, отправить их.
 *
 *	Адрес флага/регистра в посылке MODBUS передается на 1 меньше.
 *
 * 	@see STATE
 */
class TProtocolModbus
{
private:
    /// Пауза между принятыми байтами, при которой идет сброс на начало приема.
    static const uint16_t DELAY_RESET = 15000;  // лучше кратно 1500
    /// Пауза между принятыми байтами, при которой определяется окончание приема.
    static const uint16_t DELAY_READ = 35000;  // лучше кратно 3500
    /// Максимальное количество регистров доступных для чтения в одном запрсе.
    static const uint16_t MAX_NUM_REGISTERS = 32;
    /// Максимальное количество флагов доступных для чтения в одном запросе.
    static const uint16_t MAX_NUM_COILS = 256;
    /// Адрес устройства в сети по умолчанию (т.е. ошибка).
    static const uint8_t ADDRESS_ERR = 255;
    /// Минимальный адрес устройства в сети.
    static const uint8_t ADDRESS_MIN = 1;
    /// Максимальный адрес устройства в сети.
    static const uint8_t ADDRESS_MAX = 247;
    /// Максимальное кол-во байт данных в ответе на команду "Slave ID".
    static const uint8_t MAX_ID_CHARS = 30;

public:
    /// Состояния работы протокола
    enum STATE
    {
        STATE_OFF = 0,  ///< Протокол выключен.
        STATE_READ,     ///< Идет чтение посылки.
        STATE_READ_ERROR,  ///< Ошибка в принятом пакете (1.5мc < пауза < 3.5мс).
        STATE_READ_OK,      ///< Посылка принята.
        STATE_WRITE_WAIT,   ///< Ожидание нужных данных.
        STATE_WRITE_READY,  ///< Посылка готова к отправке
        STATE_WRITE,        ///< Идет отправка посылки.
        STATE_ERROR         ///< Ошибка в работе протокола.
    };

    /// Команды доступные в данном классе
    enum COM
    {
        COM_01H_READ_COILS           = 0x01,  ///< Чтение флагов.
        COM_02H_READ_DISCRETE_INPUTS = 0x02,  ///< Чтение дискретных входов.
        COM_03H_READ_HOLDING_REGISTERS = 0x03,  ///< Чтение внутренних регистров.
        COM_04H_READ_INPUT_REGISTERS = 0x04,  ///< Чтение входных регистров.
        COM_05H_WRITE_SINGLE_COIL    = 0x05,  ///< Запись одного флага.
        COM_06H_WRITE_SINGLE_REGISTER = 0x06,  ///< Запись одного внутреннего регистра.
        COM_0FH_WRITE_MULTIPLIE_COILS = 0x0F,  ///< Запись группы флагов.
        COM_10H_WRITE_MULITPLIE_REGISTERS = 0x10,  ///< Запись группы внутренних регистров.
        COM_11H_SLAVE_ID = 0x11  ///< Чтение ID подчиненного.
        //		COM_16H_MASK_WRITE_REGISTER		= 0x16,	///< Запись внутреннего
        //регистра по маске. 		COM_17H_RW_MULTIPLIE_REGISTERS	= 0x17	///< Запись/чтение
        //группы внутрених регистров.
    };

    /// Коды исключения
    enum EXCEPTION
    {
        EXCEPTION_01H_ILLEGAL_FUNCTION = 0x01,  ///< Код функции не поддерживается
        EXCEPTION_02H_ILLEGAL_DATA_ADR = 0x02,  ///< Неверный адрес регистра
        EXCEPTION_03H_ILLEGAL_DATA_VAL = 0x03,  ///< Неверное значение поля данных
        EXCEPTION_04H_DEVICE_FAILURE = 0x04  ///< В устройстве произошла ошибка
    };

    /// Коды ошибок проверки принятого multiсообщения
    enum CHECK_ERR
    {
        CHECK_ERR_NO = 0,   ///< Ошибка: нет.
        CHECK_ERR_ADR_LAN,  ///< Ошибка: неверный адрес устройства.
        CHECK_ERR_CRC,      ///< Ошибка: неверная контрольная сумма.
        CHECK_ERR_ADR,      ///< Ошибка: недопустимый адрес.
        CHECK_ERR_DATA,     ///< Ошибка: недопустимые данные.
        CHECK_ERR_DEVICE  ///< Ошибка: внутренняя ошибка устройства.
    };

    /**	Контструктор.
     *
     * 	@param buf Указатель на буфер данных.
     * 	@param size Размер буфера данных.
     */
    TProtocolModbus(uint8_t *buf, uint8_t size);

    /**	Виртуальный деструктор.
     *
     */
    //	virtual ~TProtocolModbus() {};

    /**	Возвращает значение максимального количества регистров доступных для
     * 	чтения или записи в одной посылке протокола.
     *
     * 	@return Значение максимального количества регистров.
     */
    uint16_t getMaxNumRegisters() const { return MAX_NUM_REGISTERS; }

    /**	Возвращает значение максимального количества флагов доступных для
     * 	чтения или записи в одной посылке протокола.
     *
     * 	@return Значение максимального количества флагов.
     */
    uint16_t getMaxNumCoils() const { return MAX_NUM_COILS; }

    /**	Возвращает адрес устройтсва в протоколе по-умолчанию, т.е. ошибка.
     *
     * 	@return Адрес устройства - ошибка.
     */
    uint8_t getAddressError() const { return ADDRESS_ERR; }

    /**	Возвращает минимальный адрес устройства, доступный в протоколе.
     *
     * 	@return Адрес устройства - минимальный.
     */
    uint8_t getAddressMin() const { return ADDRESS_MIN; }

    /**	Возвращает максимальный адрес устройства, досупный в протоколе.
     *
     * 	@return Адрес устройства - максимальный.
     */
    uint8_t getAddressMax() const { return ADDRESS_MAX; }

    /**	Запуск работы данного протокола.
     *
     *	Протокол будет включен в состоянии "Чтение".
     *	В случае ошибочного значения, протокол останется в текущем состоянии.
     *
     *	@see STATE
     * 	@param state Начальное состояние протокола.
     */
    void setEnable() { setState(STATE_READ); }

    /**	Остановка работы данного протокола.
     *
     */
    void setDisable() { setState(STATE_OFF); }

    /** Проверка текущего состояния работы данного протокола
     *
     *	@retval True - если текущее состояние протокола не STATE_OFF.
     *	@retval False - если протокол отключен, т.е. состояние STATE_OFF.
     */
    bool isEnable() const { return (state_ != STATE_OFF); }

    /**	Смена состояния на ожидание новой посылки.
     *
     */
    void setReadState() { setState(TProtocolModbus::STATE_READ); }

    /**	Проверка наличия принятой посылки.
     *
     * 	@retval True - при наличии принятой посылки.
     * 	@retval False - при отсутствии принятой посылки
     */
    bool isReadData() const { return (state_ == STATE_READ_OK); }

    /**	Смена состояния работы протокола.
     *
     *	Вынесена в public только для возможности тестирования работы класса!!!
     *
     *	В случае ошибочного значения, протокол останется в текущем состоянии.
     *
     * 	@param state Новое состояние работы протокола.
     */
    void setState(TProtocolModbus::STATE state);

    /**	Проверка совпадения нужного состояния с текущим.
     *
     * 	@retval True - если протокол в нужном состоянии.
     * 	@retval False - если состояние протокола отличается от нужного.
     */
    bool checkState(TProtocolModbus::STATE state) const { return (state_ == state); }

    /**	Возвращает текущее состояние протокола.
     *
     *	Вынесена в public только для возможности тестирования работы класса!!!
     *
     *	@return Текущее состояние протокола.
     */
    TProtocolModbus::STATE getState() const { return state_; }

    /**	Принятый байт даннх.
     *
     *	При переполнении буфера посылка будет просто проигнорирована.
     *
     *	Производится сброс счетчика времени, прошедшего с момента прихода
     *	последнего байта.
     *
     *	В случае текущего состояния \a STATE_READ, производится проверка
     *	счетчика времени и кол-ва принятых байт данных:
     *	- Если это первый байт данных, он будет помещен в буфер независимо от
     *	счетчика времени.
     *	- Если счетчик времени превысил \a DELAY_RESET определяется ошибка
     *	приема и состояние меняется на \a STATE_READ_ERROR.
     *
     *	@see STATE
     *	@see DELAY_RESET
     *	@param byte Байт данных.
     *	@return Возвращает кол-во принятых данных в буфере.
     */
    uint8_t push(uint8_t byte);

    /** Возвращает кол-во байт в принятой посылке или готовых к отправке.
     *
     *	Используется для тестов.
     *
     * 	@return Кол-во байт данных.
     */
    uint8_t getNumOfBytes() const { return cnt_; }

    /**	Настройка счетчика времени.
     *
     * 	Исходя из полученной скорости работы протокола, наличия контроля
     * 	четности и кол-ва стоп-битов, а так же частоты вызова функции tick(),
     * 	рассчитывается шаг счета. При этом учитывается что кол-во "бит данных"
     * 	всегда 8, а кол-во бит "контроль четности" + "стоп-биты" равно 2.
     *
     * 	Например:
     * 	для скорости  19200 и частоте вызова функции 1 раз в 50мкс, получим:
     * 	step = (period / 10^6) * (DELAY_RESET / 1.5) * (baudrate / 11) =
     * 	= (50 / 10^6) * (15000/1.5) * (19200 / 11) = 872
     *
     * 	Для частот выше 19200 рекомендуются значения: 750мкс для полуторного
     * 	интервала, и 1750 для 3.5 интервала. Поэтому шаг счета для вызова раз в
     * 	50 мкс будет::
     * 	step = DELAY_RESET * period / 750 = 15000/750 * period = 20 * 50 = 1000
     *
     *	@param baudrate Скорость работы последовательного порта, бит/с.
     *	@param period Частота вызова функции tick(), мкс.
     *	@return Рассчитанный шаг счетчика.
     */
    uint16_t setTick(uint16_t baudrate, uint8_t period);

    /**	Счет времени прошедшего с момента прихода последнего байта.
     *
     *	Счетчик считает только в состояниях \a STATE_READ и \a STATE_READ_ERROR.
     *
     *	Как только счетчик времени достигнет (превысит) \a DELAY_READ, т.е.
     *	будет обнаружена "3.5 пауза":
     *	- в состоянии \a STATE_READ необходимо не менее 4 принятых байт  для
     *	перехода в состояние принятой посылки \a STATE_READ_OK, иначе
     *	снова будет установлено \a STATE_READ.
     *	- в состоянии \a STATE_READ_ERROR, формируется состояние приема посылки
     *	\a STATE_READ (т.е. ожидание новой посылки).
     *
     * 	Вызывается с заданным интервалом.  Например, из прерывания.
     *
     *	@see DELAY_READ
     *	@see STATE_READ
     *	@see STATE_READ_ERROR
     */
    void tick();

    /**	Установка адреса устройства в сети.
     *
     * 	@param adr Адрес устройства.
     * 	@retval True - в случае смены адреса устройства.
     * 	@retval False - в случае ошибочного адреса.
     */
    bool setAddressLan(uint8_t adr);

    /**	Возвращает адрес устройства в сети.
     *
     * 	@return Адрес устройства.
     */
    uint8_t getAddressLan() const;

    /**	Отправка сообщения.
     *
     *	В случае, если состояние отличается от состояния готовности к передаче
     *	\a STATE_WRITE_READY, количество байт данных на передачу будет равно 0.
     *	При наличии данных для передачи состояние изменится на \a STATE_WRITE.
     *
     *	@see STATE_WRITE
     *	@see STATE_WRITE_READY
     * 	@return Кол-во байт данных для передачи.
     */
    uint8_t sendData();

    /**	Обработка принятых данных.
     *
     *	В случае обнаружения ошибок в принятом пакете, будет сформировано
     *	исключение. При наличии готового ответа состояние изменяется на
     *	\a STATE_WRITE_READY.
     *
     *	Формируется ответ, без контрольной суммы.
     *
     *	@see STATE_WRITE_READY
     * 	@retval True - в случае успешной обработки данных.
     * 	@retval False - в случае ошибки.
     */
    bool readData();

private:
    const uint8_t  size_;  ///> Размер буфера данных
    uint8_t *const buf_;   ///> Буфер принятых/передаваемых данных

    static const uint8_t CRC_HI[256];  ///> Массив значений для подсчета CRC
    static const uint8_t CRC_LOW[256];  ///> Массив значений для подсчета CRC

    STATE   state_;          ///> Текущее состояние работы протокола.
    uint8_t address_;        ///> Адрес устройства в сети.
    volatile uint8_t  cnt_;  ///> Кол-во принятых байт.
    volatile uint16_t tick_;  ///> Время прошедшее с момента приема последнего байта.
    uint16_t          tickStep_;  ///> Шаг счетчика паузы.

    // Проверка адреса устройства на совпадение с установленным.
    bool checkAddressLan(uint8_t adr);

    // Подсчет CRC для заданного кол-ва байт данных в буфере.
    uint16_t calcCRC(uint8_t num);

    // Возвращает принятый в посылке CRC.
    uint16_t getCRC() const;

    // Добавляет к имеющейся в буфере посылке контрольную сумму.
    void addCRC();

    // Проверка полученной посылки на соответствие протоколу.
    TProtocolModbus::CHECK_ERR checkReadPackage();

    // Ответ на запрос с кодом исключения.
    void setException(TProtocolModbus::EXCEPTION code);

    // Обработка команды чтения флагов 0x01.
    bool comReadCoils();

    // Обработка команды чтения дискретных входов 0x02
    bool comReadDInputs();

    // Обработка команды чтения внутренних регистров 0x03.
    bool comReadRegisters();

    // Обработка команды чтения входных регистров 0x04
    bool comReadIRegisters();

    // Обработка команды записи флага 0x05.
    bool comWriteCoil();

    // Обработка команды записи регистра 0x06.
    bool comWriteRegister();

    // Обработка команды записи группы флагов 0x0F.
    bool comWriteCoils();

    // Обработка команды записи группы регистров 0x10.
    bool comWriteRegisters();

    // Обработка команды чтения инфорации об устройстве 0x11.
    bool comReadID();

    /**	Возвращает стартовый адрес регистра/флага в посылке.
     *
     * 	@return Стартовый адрес регистра или флага в принятой посылке.
     */
    uint16_t getStartAddress() const { return ((uint16_t) buf_[2] << 8) + buf_[3] + 1; }

    /**	Возвращает количество регистров/флагов в посылке.
     *
     * 	@return Количество регистров/флагов в посылке.
     */
    uint16_t getNumOfAddress() const { return ((uint16_t) buf_[4] << 8) + buf_[5]; }

    /** Чтение флагов.
     *
     *	Проводится проверка корректности адреса. Если он находится в допустимом
     *	диапазоне, возвращается текущее состояние флага.
     *
     *	По умолчанию, значения по адресам:
     *	- с 1 по 100 установлены;
     *	- c 101 по 200 сброшены;
     *	- c 201 по 300 установлены;
     *	- с 301 и далее не существуют, т.е. ошибка адреса.
     *
     *	@param adr Адрес флага.
     *	@param val [out] Состояние флага.
     *	@retval CHECK_ERR_NO Ошибок при считывании флага не возникло.
     *	@retval CHECK_ERR_ADR Недопустимый адрес флага.
     */
    virtual TProtocolModbus::CHECK_ERR readCoil(uint16_t adr, bool &val);

    /**	Чтение дискретных входов.
     *
     *	Проводится проверка корректности адреса. Если он находится в допустимом
     *	диапазоне, возвращается текущее состояние дискретного входа.
     *
     *	По умолчанию, значения по адресам:
     *	- с 1 по 100 установлены;
     *	- c 101 по 200 сброшены;
     *	- c 201 по 300 установлены;
     *	- с 301 и далее не существуют, т.е. ошибка адреса.
     *
     *	@param adr Адрес дискретного входа.
     *	@param val [out] Состояние дискретного входа.
     *	@retval CHECK_ERR_NO Ошибок при считывании дсикретного входа не возникло.
     *	@retval CHECK_ERR_ADR Недопустимый адрес дискретного входа.
     */
    virtual TProtocolModbus::CHECK_ERR readDInput(uint16_t adr, bool &val);

    /**	Чтение внутренних регистров.
     *
     *	Проводится проверка корректности адреса. Если он находится в допустимом
     *	диапазоне, возвращается текущее значение внутреннего регистра.
     *
     *	По умолчанию, значения по адресам:
     *	- с 1 по 100 включительно равны адресу;
     *	- c 101 по 200 включительно равны значению по умолчанию, т.е. 0xFFFF;
     *	- с 201 по 300 включительно равны адресу;
     *	- c 300 и далее не существуют, т.е. ошибка адреса.
     *
     *	@param adr Адрес внутреннего регистра.
     *	@param val [out] Значение внутреннего регистра.
     *	@retval CHECK_ERR_NO Ошибок при считывании внутреннего регистра не возникло.
     *	@retval CHECK_ERR_ADR Недопустимый адрес внутреннего регистра.
     */
    virtual TProtocolModbus::CHECK_ERR readRegister(uint16_t adr, uint16_t &val);

    /**	Чтение входных регистров.
     *
     *	Проводится проверка корректности адреса. Если он находится в допустимом
     *	диапазоне, возвращается текущее значение входного регистра.
     *
     *	По умолчанию, значения по адресам:
     *	- с 1 по 100 включительно равны адресу;
     *	- c 101 по 200 включительно равны значению по умолчанию, т.е. 0xFFFF;
     *	- с 201 по 300 включительно равны адресу;
     *	- c 300 и далее не существуют, т.е. ошибка адреса.
     *
     *	@param adr Адрес входного регистра.
     *	@param val [out] Значение входного регистра.
     *	@retval CHECK_ERR_NO Ошибок при считывании регистра не возникло.
     *	@retval CHECK_ERR_ADR Недопустимый адрес регистра.
     */
    virtual TProtocolModbus::CHECK_ERR readIRegister(uint16_t adr, uint16_t &val);

    /**	Запись флагов.
     *
     *	Проводится проверка корректности адреса. Выход за максимальный или
     *	минимальный адреса считается ошибкой.
     *
     *	По умолчанию доступны адреса:
     *	- c 1 по 100 включительно, для записи любого значения;
     *	- c 101 по 200 включительно, только для установки;
     *	- c 201 по 300 включительно, только для сброса;
     *	- c 301 и далее не существуют, т.е ошибка.
     *
     *	@param adr Адрес флага.
     *	@param val Состояние флага.
     * 	@retval CHECK_ERR_NO Ошибок при записи флага не возникло.
     * 	@retval CHECK_ERR_ADR Недопустимый адрес флага.
     *	@retval CHECK_ERR_DEVICE Возникла внутренняя ошибка.
     */
    virtual TProtocolModbus::CHECK_ERR writeCoil(uint16_t adr, bool val);

    /**	Запись внутренних регистров.
     *
     * 	Проводится проверка корректности адреса. Выход за максимальный или
     *	минимальный адреса считается ошибкой.
     *
     *	По умолчанию доступны адреса:
     *	- с 1 по 100 включительно, для записи любого значения;
     *	- с 101 по 200 включительно, для записи числа не более 100:
     *	- c 201 по 300 включительно, для записи числа не менее 1000.
     *	- с 301 и далее не существуют, т.е. ошибка.
     *
     *	@param adr Адрес регистра.
     *	@param val Состояние регистра.
     * 	@retval CHECK_ERR_NO Ошибок при записи регистра не возникло.
     * 	@retval CHECK_ERR_ADR Недопустимый адрес регистра.
     *	@retval CHECK_ERR_DEVICE Возникла внутренняя ошибка.
     */
    virtual TProtocolModbus::CHECK_ERR writeRegister(uint16_t adr, uint16_t val);

    /**	Чтение ID.
     *
     * 	В посылку для ответа помещаются необходимые данные. Последним байтом
     * 	помещается индикатор состояния: ON - 0xFF, OFF- 0x00.
     *
     * 	По умолчанию будет отправлено сообщение "Virtual" и индикатор состояния
     * 	OFF.
     *
     *	@param buf Указатель на буфер, для записи данных.
     *	@param size [out] Передается максимальный размер сообщения, не включая
     *	байт для индикатора состояния. Возвращается кол-во байт данных
     *	записанных в буфер.
     * 	@retval CHECK_ERR_NO Ошибок при считывании  не возникло.
     *	@retval CHECK_ERR_DEVICE Возникла внутренняя ошибка.
     */
    virtual TProtocolModbus::CHECK_ERR readID(char *buf, uint8_t &size);
};

#endif /* PROTOCOL_MODBUS_H_ */
