/*
 * LocalParams.h
 *
 *  Created on: 25.03.2015
 *      Author: Shcheblykin
 */

#ifndef LOCALPARAMS_H_
#define LOCALPARAMS_H_

#include "param.h"

class LocalParams {
	/// Максимальное количество параметров в списке.
	static const uint8_t MAX_NUM_OF_PARAMS = 25;

	/// Максимальное количество байт для битовых переменных.
//	static const uint8_t MAX_BUF_BITS_VALUES = 12;

public:

	/// Текущее состояние значения параметра
	enum STATE {
		STATE_NO_ERROR = 0,	///< Значение корректно.
		STATE_READ_PARAM,	///< Идет считывание параметра.
		STATE_ERROR			///< Значение ошибочное.
	};

	/// Конструктор
	LocalParams();

	/** Установка нового значения параметра и его проверка на корректность.
	 *
	 * 	@param val Новое значение параметра.
	 */
	void setValue(int16_t val);

	/**	Возвращает текущее значение параметра.
	 *
	 *	Если текущий параметр битовый (\a Param::PARAM_BITES), то возвращается
	 *	значение 0 или 1 для текущего под.номера \a currSameParam. Иначе
	 *	возвращается текущее значение параметра.
	 *
	 * 	@return Текущее значение параметра.
	 */
	int16_t getValue() const;

	/**	Возвращает текущий байт для битовых параметров.
	 *
	 * 	@return Текущий байт для битового параметра.
	 */
	uint8_t getValueB() const;

	/**	Возвращает текущее состояние параметра.
	 *
	 * 	@retval True Ошибочное значение.
	 * 	@retval False Корректное значение.
	 */
    STATE getState() const { return state; }

	/**	Переход к следующему параметру.
	 *
	 * 	Если достигли конца списка, происходит прыжок на первый параметр.
	 * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
	 * 	считывания значения параметра.
	 *
	 * 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
	 */
	void nextParam();

	/**	Переход к предыдущему параметру.
	 *
	 * 	Если достигли начала списка, происходит прыжок на последний параметр.
	 * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
	 * 	считывания значения параметра.
	 *
	* 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
	 */
	void prevParam();

	/** Переход к следующему однотипному параметру.
	 *
	 *	Если достигли конца списка , происходит прыжок на первый параметр.
	 * 	Если был осуществлен переход (кол-во однотипных параметров больше 1),
	 * 	то ждем считывания значения параметра.
	 */
	void nextSameParam();

	/** Переход к предыдущему однотипному параметру.
	 *
	 *	Если достигли начала списка, происходит прыжок на последний параметр.
	 *	Если был осуществлен переход (кол-во однотипных параметров больше 1),
	 * 	то ждем считывания значения параметра.
	 */
	void prevSameParam();

	/** Добавление в список нового параметра.
	 *
	 * 	В случае переполнения буфера параметров, будет возвращена ошибка.
	 *
	 * 	@param *newParam Указатель на структуру параметра.
	 * 	@retval True Параметр добавлен.
	 * 	@retval False Буфер переполнен, параметр небыл добавлен.
	 *
	 */
	bool addParam(eGB_PARAM newParam);

	/**	Очистка списка параметров.
	 *
	 * 	По умолчанию устанавливается первый параметр из списка
	 * 	\a GB_PARAM_TIME_SYNCH, при этом количество параметров обнуляется.
	 */
	void clearParams();

	/**	Возвращает минимальное значение параметра.
	 *
	 * 	@return Минимальное значение параметра.
	 */
    int16_t getMin() const;

	/**	Возвращает максимальное значение параметра.
	 *
	 *	Для строковых параметров, в максимуме которых хранится кол-во элементов
	 *	списка, будет возвращено значение максимального значения с учетом
	 *	минимального max = min + flash_max - 1.
	 *
	 * 	@return Максимальное значение параметра.
	 */
	int16_t getMax() const;

	/**	Возвращает номер текущего параметра.
	 *
	 * 	@return Номер текущего параметра.
	 */
	uint8_t getNumOfCurrParam() const {	return currParam + 1; }

	/**	Возвращает количество текущих параметров.
	 *
	 * 	@return Количество текущих параметров.
	 */
	uint8_t getNumOfParams() const {
		return numOfParams;
	}

	/**	Возвращает текущий номер однотипного параметра начиная с 1.
	 *
	 * 	Если номер текущего параметра превышает максимальное количество, будет
	 * 	возвращен максимум.
	 *
	 * 	@return Текущий номер однотипного параметра.
	 */
	uint8_t getNumOfCurrSameParam() const;

	/**	Возвращает количество однотипных парметров.
	 *
	 * 	Например, если для каждой из команд возможно установить свое значение
	 * 	"Длительность команды", то тут будет количество команд.
	 *
	 * 	@return Количество однотипных параметров.
	 */
    uint8_t getNumOfSameParams() const;

	/**	Возвращает текущий параметр.
	 *
	 * 	@return Текущий параметр.
	 */
	eGB_PARAM getParam() const {
		return param[currParam];
	}

	/** Установка кол-ва команд на передачу.
	 *
	 * 	@param numComPrd Кол-во команд на передачу.
	 */
	void setNumComPrd(uint8_t numComPrd) {
		this->numComPrd = numComPrd;
	}

	/** Установка кол-ва команд на приеме.
	 *
	 * 	@param numComPrd Кол-во команд на приеме.
	 */
	void setNumComPrm(uint8_t numComPrm) {
		this->numComPrm = numComPrm;
	}

	/**	Установка количества аппаратов в линии
	 *
	 * 	@param numDevices Количество аппаратов в линии
	 * 	@argval 2
	 * 	@argval 3
	 */
	void setNumDevices(uint8_t numDevices) {
		this->numDevices = numDevices;
	}

private:
	eGB_PARAM param[MAX_NUM_OF_PARAMS]; ///< Массив параметров.

	int16_t val;			///< Значение текущего параметра.

	uint8_t currParam;		///< Номер текущего параметра.

	uint8_t numOfParams;	///< Количество параметров в текущем списке.

	uint8_t currSameParam;	///< Номер текущего однотипного параметра.

	STATE state;			///< Флаг ошибки в текущем значении.

	uint8_t numComPrm;		///< Количество команд на приеме.

	uint8_t numComPrd;		///< Количество команд на передачу.

	uint8_t numDevices;		///< Количество аппаратов в линии.

	/**	Проверка установленного значения параметра на корректность.
	 *
	 * 	В случа ошибочного значения в состояние \a state будет записано
	 * 	значение STATE_ERROR, если все верно - \a STATE_NO_ERROR.
	 *
	 *	@see STATE_ERROR
	 *	@see STATE_NO_ERROR
	 */
	void checkValue();

	/**	Обновление параметра.
	 *
	 * 	Текущий статус \a state сбрасывается в ожидание чтения STATE_READ_PARAM,
	 * 	а значение параметра сбрасывается в 0.
	 *
	 */
	void refreshParam();
};

#endif /* LOCALPARAMS_H_ */
