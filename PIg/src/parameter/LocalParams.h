/*
 * LocalParams.h
 *
 *  Created on: 25.03.2015
 *      Author: Shcheblykin
 */

#ifndef LOCALPARAMS_H_
#define LOCALPARAMS_H_

#include "param.h"

class LocalParams
{
    /// Максимальное количество параметров в списке.
    static const uint8_t MAX_NUM_OF_PARAMS = 25;

    struct prop_t
    {
        eGB_PARAM param;
        bool      readOnly;
    };

public:
    /// Текущее состояние значения параметра
    enum STATE
    {
        STATE_NO_ERROR = 0,  ///< Значение корректно.
        STATE_READ_PARAM,    ///< Идет считывание параметра.
        STATE_ERROR          ///< Значение ошибочное.
    };

    /// Конструктор
    LocalParams();

    /** Установка нового значения параметра и его проверка на корректность.
     *
     * 	@param val Новое значение параметра.
     */
    void setValue(int16_t val);

    /**	Возвращает текущее значение параметра.
     *
     *	Если текущий параметр битовый (\a Param::PARAM_BITES), то возвращается
     *	значение 0 или 1 для текущего под.номера \a currSameParam. Иначе
     *	возвращается текущее значение параметра.
     *
     * 	@return Текущее значение параметра.
     */
    int16_t getValue() const;

    /**	Возвращает текущий байт для битовых параметров.
     *
     * 	@return Текущий байт для битового параметра.
     */
    uint8_t getValueB() const;

    /**	Возвращает текущее состояние параметра.
     *
     * 	@retval True Ошибочное значение.
     * 	@retval False Корректное значение.
     */
    STATE getState() const { return state; }

    /**	Переход к следующему параметру.
     *
     * 	Если достигли конца списка, происходит прыжок на первый параметр.
     * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
     * 	считывания значения параметра.
     *
     * 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
     */
    void nextParam();

    /**	Переход к предыдущему параметру.
     *
     * 	Если достигли начала списка, происходит прыжок на последний параметр.
     * 	Если был осуществлен переход (кол-во параметров больше 1), то ждем
     * 	считывания значения параметра.
     *
     * 	Если параметр был изменен, то устаналивается флаг обновления \a refresh.
     */
    void prevParam();

    /** Переход к следующему однотипному параметру.
     *
     *	Если достигли конца списка , происходит прыжок на первый параметр.
     * 	Если был осуществлен переход (кол-во однотипных параметров больше 1),
     * 	то ждем считывания значения параметра.
     */
    void nextSameParam();

    /** Переход к предыдущему однотипному параметру.
     *
     *	Если достигли начала списка, происходит прыжок на последний параметр.
     *	Если был осуществлен переход (кол-во однотипных параметров больше 1),
     * 	то ждем считывания значения параметра.
     */
    void prevSameParam();

    /** Добавление в список нового параметра.
     *
     * 	В случае переполнения буфера параметров, будет возвращена ошибка.
     *
     * 	@param[in] newParam Параметр.
     * 	@param[in] readonly true - только для чтения, иначе false.
     * 	@retval True Параметр добавлен.
     * 	@retval False Буфер переполнен, параметр небыл добавлен.
     *
     */
    bool addParam(eGB_PARAM newParam, bool readonly = false);

    /**	Проверяет текущий параметр на возможность только чтения.
     * 	@return true если параметр можно только просматривать, иначе false.
     */
    bool isReadOnly();

    /**	Очистка списка параметров.
     *
     * 	По умолчанию устанавливается первый параметр из списка
     * 	\a GB_PARAM_TIME_SYNCH, при этом количество параметров обнуляется.
     */
    void clearParams();

    /**	Возвращает минимальное значение параметра.
     *
     * 	@return Минимальное значение параметра.
     */
    int16_t getMin() const;

    /**	Возвращает максимальное значение параметра.
     *
     *	Для строковых параметров, в максимуме которых хранится кол-во элементов
     *	списка, будет возвращено значение максимального значения с учетом
     *	минимального max = min + flash_max - 1.
     *
     * 	@return Максимальное значение параметра.
     */
    int16_t getMax() const;

    /**	Возвращает номер текущего параметра.
     *
     * 	@return Номер текущего параметра.
     */
    uint8_t getNumOfCurrParam() const { return currParam + 1; }

    /**	Возвращает количество текущих параметров.
     *
     * 	@return Количество текущих параметров.
     */
    uint8_t getNumOfParams() const { return numOfParams; }

    /**	Возвращает текущий номер однотипного параметра начиная с 1.
     *
     * 	Если номер текущего параметра превышает максимальное количество, будет
     * 	возвращен максимум.
     *
     * 	@return Текущий номер однотипного параметра.
     */
    uint8_t getNumOfCurrSameParam() const;

    /**	Возвращает количество однотипных парметров.
     *
     * 	Например, если для каждой из команд возможно установить свое значение
     * 	"Длительность команды", то тут будет количество команд.
     *
     * 	@return Количество однотипных параметров.
     */
    uint8_t getNumOfSameParams() const;

    /**	Возвращает текущий параметр.
     *
     * 	@return Текущий параметр.
     */
    eGB_PARAM getParam() const { return param[currParam].param; }

    /** Установка кол-ва команд на передачу.
     *
     * 	@param numComPrd Кол-во команд на передачу.
     */
    void setNumComPrd(uint8_t numComPrd) { this->numComPrd = numComPrd; }

    /** Установка кол-ва команд на приеме.
     *
     * 	@param numComPrd Кол-во команд на приеме.
     */
    void setNumComPrm(uint8_t numComPrm) { this->numComPrm = numComPrm; }

    /**	Установка количества аппаратов в линии
     *
     * В случае ошибочного значения будет установлено 2.
     *
     * 	@param[in] numDevices Количество аппаратов в линии
     * 	@argval 2
     * 	@argval 3
     */
    void setNumDevices(uint8_t numDevices) { this->numDevices = (numDevices == 3) ? (3) : (2); }

private:
    prop_t  param[MAX_NUM_OF_PARAMS];  ///< Массив параметров.
    int16_t val;                       ///< Значение текущего параметра.
    uint8_t currParam;                 ///< Номер текущего параметра.
    uint8_t numOfParams;  ///< Количество параметров в текущем списке.
    uint8_t currSameParam;  ///< Номер текущего однотипного параметра.
    STATE   state;          ///< Флаг ошибки в текущем значении.
    uint8_t numComPrm;      ///< Количество команд на приеме.
    uint8_t numComPrd;      ///< Количество команд на передачу.
    uint8_t numDevices;     ///< Количество аппаратов в линии.

    /**	Проверка установленного значения параметра на корректность.
     *
     * 	В случа ошибочного значения в состояние \a state будет записано
     * 	значение STATE_ERROR, если все верно - \a STATE_NO_ERROR.
     *
     *	@see STATE_ERROR
     *	@see STATE_NO_ERROR
     */
    void checkValue();

    /**	Обновление параметра.
     *
     * 	Текущий статус \a state сбрасывается в ожидание чтения STATE_READ_PARAM,
     * 	а значение параметра сбрасывается в 0.
     *
     */
    void refreshParam();
};

#endif /* LOCALPARAMS_H_ */
